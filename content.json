{"meta":{"title":"Onece || Aaras","subtitle":null,"description":null,"author":"极度简单.","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"精讲自己理解","date":"2022-09-19T15:40:04.785Z","updated":"2022-09-19T11:18:02.326Z","comments":true,"path":"2022/09/19/精讲自己理解/","link":"","permalink":"http://example.com/2022/09/19/%E7%B2%BE%E8%AE%B2%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3/","excerpt":"","text":"js基础部分- 变量是什么？可变化的量，由变量名和变量值组成，名称是标识，值是可以变化的，一个变量对应一块小内存。拿var a = 1来说， a相当于这块内存的标识名称，用于查找这块内存，变量值就是1就是内存中保存的数据，可以通过访问a去找到这个数据 - 基本类型变量与引用类型变量的区别是什么？基本数据类型数据存放在堆内存中，引用数据类型存放在堆内存中的是地址值，数据是存放在栈内存中，通过访问地址值去访问数据 - 函数传参到底是值传递还是引用传递？1.函数调用时，是将实参变量的数据拷贝一份赋值给形参变量 2.只是实参变量数据可能是基本数据类型，也可能是引用数据类型 - 说说你对作用域和作用域链的理解作用域的话就是一个变量可以合法使用的范围或区域，有分为全局作用域和局部作用域，局部作用域又有函数作用域和块级作用域，块级作用域必须是使用了const或let才产生的，作用域起到隔离变量，避免了变量重名冲突的问题，就是允许了不同作用域中可以有重名的变量，作用域可能有嵌套关系，在内部作用域里面查找某一个变量的时候，它的查找顺序是先找自身有没有变量，如果没有就由内向外查找，一直找到全局为止，如果全局找不到就会报错，这就形成了作用域链 - 说说变量提升与函数提升1.变量提升就是变量声明提升，在变量声明语句前就可以访问到这个变量，只是值为undefined 2.函数提升就是函数声明提升，在函数声明语句之前就可以调用执行该函数，因为在执行全局代码和函数前会进行预解析，将var声明的变量和函数声明都会放在最前面执行 - 你说说对js中闭包的理解闭包就是函数嵌套函数，然后内部函数可以访问外部函数的变量，当调用外部函数时就会产生闭包，作用是防止变量污染，延长局部变量的生命周期，让函数外部能反复间接操作内部的局部变量。如果没有及时的释放闭包，会造成内存的泄露，如果内存泄露多了的话，可能会造成内存溢出。但是现在的垃圾回收机制就不存在闭包引起的内存泄露，只有在7--8年前的电脑才会出现这个问题。（内部函数会将地址值返回出去，外部通过一个变量接收并调用）常见的闭包有防抖和节流函数。 写一个简单的闭包123456789101112function fn1() &#123; var a = 2; function fn2() &#123; a++; console.log(a); &#125; return fn2;&#125; var f = fn1();f();f();f = null - 防抖和节流节流是多次变少次，防抖是多次变一次，主要解决如果更新界面，界面更新卡顿与发送ajax请求过多，造成很多没必要的请求，导致服务器压力过大，主要应用场景DOM元素的实现（mousemove），疯狂点击(click),输入框实时搜索联想(keyup/input) - 深浅拷贝深浅拷贝是对于引用数据类型来说的，浅拷贝拷贝的是地址值，我们修改拷贝后的数据会影响到原数据，深拷贝拷贝的是具体的数据，我们修改拷贝后的数据不会影响到原数据 - 垃圾回收机制浏览器有一个专门的线程，它主要工作是判断一个对象是否是垃圾对象，如果是清除其内存数据，并标记内存为空闲状态，它有两种方法，最初级的是引用计数法，现在都不用了，把“对象是否不再需要”简化定义为“对象有没有引用指向它”，每个对象内部都标记一下引用它的总个数，如果引用个数为0时，即为垃圾对象，还有一个方法是当前垃圾回收算法的基础，称为标记清除法，是把“对象是否不再需要”简化定义为“对象是否可以获得”，它是从根对象（也就是window）开始查找所有引用的对象，并标记为“使用中” ，没有标记为使用中的就是垃圾对象 - 内存溢出和内存泄露当程序中某个内存数据不再需要使用，但是未及时释放会造成内存泄露，常见的情况有，意外的全局变量，没有及时清除的定时器，没有及时解绑的监听，没有及时释放的闭包，这些造成内存泄露堆积过多的话最终会导致内存溢出，内存溢出是运行程序超过了系统分配的最大剩余内存。 - this的指向问题1.一般情况下： fn(): 函数直接调用 ---&gt; this是指向window new fn(): new调用 ---&gt; this是指向新创建的对象 obj.fn(): 通过对象调用 ---&gt; this是指向obj 箭头函数 ---&gt; 没有自己的this，this指向是外部作用域的this fn.call/apply:通过对象的call或apply方法 ---&gt; this指向的是方法的第一个参数 2.特殊情况下: bind方法返回的函数 ---&gt; this指向的是方法的第一个参数 回调函数（它不是我们调用的，但是最后却执行了） 定时器/ajax/promise/数组遍历相关的方法回调 ---&gt; this指向是window vue控制的回调函数 ---&gt; this指向是组件的实例 react控制的生命周期回调，事件监听回调 ---&gt; this指向是组件对象/undefined - 如何改变函数中的this指向1.bind方法 2.将this保存一份然后使用 3.使用箭头函数 - new关键字的作用1.开辟空间 2.修改this指向 3.执行函数 4.添加proto，指向函数的显式原型对象 5.返回this - 说说你对原型和原型链的理解1.原型就是每个函数都有一个显示原型属性：prototype 2.每个实例对象都有一个隐式原型：__proto__ 3.实例对象的__proto__与对应函数的prototype都指向原型对象 4.原型对象上有一个constructor属性指向对应的构造函数 原型链就是从对象的隐式原型开始，连接的所有对象，所以也可称为隐式原型链，在查找对象属性或调用对象方法时，会先在对象自身上查找，找不到就会沿着原型链查找，利用原型链可以实现继承 - 检测数据类型的方式 typeof: typeof:返回的是数据类型的字符串表达形式 instanceof&#x2F;constructor 不能判断基本数据类型,可以检测数组和正则 Object.prototype.toString 可以通过Object.prototype.toString方法，判断某个对象值属于哪种内置类型 分为null、string、boolean、number、undefined、array、function、object、date、math - 编码实现继承继承有构造函数继承，原型继承，原型继承会改变子类构造器，组合继承 构造继承 Person.call(this,name,age) 构造继承优缺点: 优点：多继承，call调用强行将this指向当前子类 缺点：只能继承构造函数内的私有属性和方法，每个类都需要call调用一次父类，影响性能 原型继承 Student.prototype &#x3D; new Person() 注：这里改变子类的原型，子类的构造器为父类的，所以要修改回来 Student.prototype.constructor &#x3D; Student 原型继承优缺点: 优点：简单，与父类共享原型 缺点：父类实例对象会覆盖子类的原型对象,无法多继承 组合继承：(构造继承+原型继承+改变子类构造器) 组合继承优缺点: 优点：原型指向问题解决了多继承问题 缺点：调用两次构造函数，生成两份实例，浪费性能 - 面向对象的三大特征封装，继承，多态。封装是将可复用的代码用一个结构包装起来，后面可以反复使用，继承是为了复用代码，从而减少编码，多态就是多种形态 - 同步与异步的区别js是单线程编程语言，同步会阻塞代码执行，异步不会阻塞代码执行，同步是从上往下按顺序依次执行的，只有将一个任务完全执行完后，才会执行后面的，所以会阻塞后面的代码执行，异步是js通过事件循环机制来实现js的单线程异步，启动任务后，立即向下执行，等同步代码执行完后才执行回调函数，不会阻塞后面的代码执行，异步回调函数会即使触发了，也是要先放入队列中等待执行，只有等同步任务或前面的异步任务执行完才执行 - 宏任务和微任务异步代码也分为先后,先执行微任务再执行宏任务 1.先执行主线程的同步代码直到结束,如果遇到微任务则放入微任务队列,如果遇到宏任务则交给对应的模块管理 2.检查微任务队列,并执行微任务中的回调函数,直到全部执行完成 3.执行宏任务中的异步代码,当执行的过程中遇到了微任务,则继续放入微任务队列 4.每次执行完一个宏任务的时候,都会再次检查微任务队列,执行微任务直到结束 5.继续轮询宏任务... - 事件轮询机制代码分为同步代码和异步代码，js执行代码的顺序是先异步（整个script是异步的）再执行同步代码（script内部的代码），再执行异步代码（常见的异步回调），在执行主线程的过程中，如果遇到了异步代码，则把异步代码的回调函数交给浏览器的事件管理模块管理（DOM管理模块/ajax管理模块/定时器管理模块），浏览器的管理模块对事件进行监听，当回调函数已经达到条件需要执行的时候，会把回调函数依次放入回调队列，当主线程的同步代码执行完毕后，会轮询回调队列，依次执行回调队列中的回调函数 - 说说对promise的理解promise是ES6中新推出的异步编程解决方案，通过promise.then的链式调用方法，解决嵌套回调的回调地狱问题，在它推出之前的异步语法都是用的宏任务，它是用的微任务，并且指定读取结构数据的回调函数时机更灵活，可以在请求前/请求后/请求完成后去指定，promise是有三种状态的分别是pending（等待状态），resolved/fulfilled（成功状态），rejected（失败状态）promise的状态改变有两种，是从等待状态变为成功或失败状态，只会改变一次是不可逆的，改变promise的状态方法得调用resolve(),reject()或主动抛出throw error - promise的then()的理解.then()方法总是返回一个新的promise，新的promise的结果状态由then指定的回调函数执行的结果决定，有主动抛出错误，调用resolve(),reject()方法或直接return一个值 - promise的all()的理解all()方法，批量一次发送多个异步请求，当都成功时返回一个数组，数组里面存储所有成功promise的结果，要是有一个失败的话，返回值就是失败的那个promise的值 - promise的race()理解race()方法，返回值是不论成功或失败只返回响应最快的那一个请求 async&#x2F;await方法async和await是消灭异步回调的终极解决方案，能简化promise对象的使用，不用再使用.then/.catch来指定回调函数，它和promise并不互斥，两者相辅相成。async函数的返回值是promise对象，await等待的是一个promise，如果await等待的是一个基本数据，就会直接返回这个数据 ES6新特性 块级作用域 解构赋值 模板字符串 箭头函数 扩展运算符 class类 模块化语法 export是暴露 import能动态导入，拆分打包，用于懒加载 异步语法 Set和Map 代理Proxy 模块化和组件化重绘和重排不会影响元素的布局改变只会重绘，重绘是浏览器会重新绘制受影响的部分到屏幕的过程。因为元素的尺寸、布局、隐藏等等改变引起页面的重新渲染，这个过程称为重排，重排肯定会引起重绘，但是重绘不一定会引发重排，一个元素的重排会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。 事件冒泡的流程事件的执行过程为捕获、目标、冒泡，事件在目标元素上处理后，会由内向外逐层传递给所有外层元素处理，主要用于事件代理事件委托 说说你对ajax的理解ajax请求是一种特别的http请求，对服务器端来说，没有任何区别，区别在浏览器端，浏览器端发请求：只有xhr/fetch发出的才是ajax请求，其他所有的都是非ajax请求，浏览器端接收到响应，浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面，如果是ajax请求，浏览器中ajax引擎不会对页面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据 响应状态码（要添加）1XX：请求正在处理中 2XX：请求成功 3XX：需要重定向，浏览器直接跳转 4XX：客户端请求错误 5XX：服务器端错误 封装一个简易的ajax请求1.创建一个xhr对象（XMLHttpRequest） const xhr = new XMLHttpRequest() 2.初始化一个异步请求（这时还没发请求） xhr.open(&quot;方式&quot;,&quot;地址&quot;,&quot;是否异步，默认为true&quot;) 3.发送请求 xhr.send() 4.监听服务器返回的结果 xhr.onreadystate 5.判断服务器是否返回了所有结果 if(xhr.readyState === 4)&#123;&#125; 6.成功之后判断返回的响应状态码是否大于等于200小于300,没问题就打印响应体 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)； 跨域跨域就是违背了同源策略，发送ajax请求时，浏览器要求当前网页和服务器必须同源，否则会抛出跨域错误，而同源就是协议，域名，端口三者都相同，解决跨域的第一种方式是JSONP，是通过script标签进行发请求，因为script标签不受同源策略限制，缺点是只能发送get请求，第二种方式是cors，服务器返回一个响应头允许浏览器跨域，第三种方式是配置代理，在webpack里的dev-server中配置proxy，在vue2中的vue.config.js,在vue3中是在vite.config.js中配置，发请求是向本地的代理服务器发送请求，代理服务器转发请求到相应的接口上去 axios的二次封装使用axios的create方法创建实例对象，去配置通用的基础路径和请求超时时间，在请求拦截器中携带token和用户临时ID利用它去做购物车处理，也可以在里面配置进度条功能，响应拦截器分为成功的回调和失败的回调，我们可以在成功或失败的回调里结束进度条，在成功的回调中可以返回response.data，可以让具体请求简单一些，在失败的回调中对失败进行统一提示，对token过期的错误进行处理，如果判断响应状态码为401就清除之前的token去跳转到登录页，并提示登录过期需要重新登录 get请求和post请求的区别get是获取数据的,而post是提交数据的 GET可以缓存,而POST不可缓存 post发送的数据更大,get有url长度限制 post能发送更多的数据类型(get只能发送ASCll字符) 从输入url到渲染出页面的整个过程1. DNS查询/解析：将域名地址解析成ip地址 2. TCP连接:TCP三次握手 3. 发送请求 4. 返回响应 5. 渲染页面(浏览器渲染流程相当于是把这步进行详细说明) 6. 断开连接：TCP四次挥手 浏览器渲染流程1. 根据结构生成DOM树 2. 根据样式生成CSSOM数 3. 结合DOM树和CSSOM数生成render Tree(渲染树) 4. 对渲染树中的结构进行分层，生成图层树 5. 根据图层树，生成图层的绘制指令 6. 栅格化：将图层划分为图块 7. 绘制和展示 浏览器三次握手TCP协议，在发送数据前，通信双方必须在彼此间建立一条连接，三次握手就是建立连接时发送的三次数据包，三次握手的意义在于确保通信双方都能确定对方的接收和发送能力都正常，过程： 1.客户端向服务端发送一个syn(请求)数据包，请求连接 2.服务端接收到客户端的syn数据包(服务端确定客户端发送能力正常),服务端向客户端发送syn+ack(应答)数据包 3.客户端接收服务端的数据包(客户端确定服务端的发送和接收能力正常)，客户端向服务端发送ack数据包 4.服务端接收ack数据包(确定客户端接收能力正常) 浏览器四次挥手TCP的连接拆除需要发送四个包，因此称为四次挥手 TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次，过程： 1.客户端发送Fin(释放连接)字段请求断开连接 2.服务端发送ack字段应答断开请求 3.服务端等数据全部处理完毕，发送Fin字段请求断开连接 4.客户端发送ack字段应答断开请求 浏览器的强缓存与协商缓存浏览器的强缓存简单来讲,就是浏览器直接使用自己的缓存,不进行任何的请求，协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识觉得是否使用缓存的过程(命中状态码为304) 区别HTTP与HTTPS1.http协议的数据传输都是明文，如果攻击者截取了传输报文，就可以直接读懂其中的信息，不适合传输一些敏感信息，如密码等 2.https协议是http的升级版，通过和SSL或TLS组合使用进行加密http的内容，是带加密传输，身份认证的网络协议，要比http协议安全 - 前台数据存储存储方式有三种：cookie(会话，持久化），sessionStorage，localStorage（后面两种都是h5之后出来的新特性） - sessionStorage与localStorage浏览器刷新，两个存储都在，浏览器关闭重新打开后，sessionStorage中数据不在，localStorage的还在 - cookie跟sessionStorage与localStorage的差别sessionStorage与localStorage某种程度上来说是用来代替cookie，因为cookie分为会话cookie和持久化cookie两种，会话cookie与sessionStorage很像，持久化cookie与localStorage很像，但是有一定差别，cookie容量小，其他两个存储方式大，cookie请求时会自动携带，cookie使用起来复杂，浏览器可以禁用cookie，但是对sessionStorage和localStorage不行，这就是我的理解，如果公司有这方面的需求，我会在网上找资料再进行学习学习 手写代码1.函数的call()/apply()/bind() 2.函数的节流(throttle)防抖(debounce) 3.数组去重(unique) 4.数组扁平化(flatten) 5.深拷贝 6.自定义new和instanceof工具函数 7.字符串处理 8.简单的排序：冒泡、选择、插入(必须要会一个) webpack五大护法1.Entry：入口起点(entry point) 打包时，第一个被访问的源码文件，指示webpack应该使用哪个模块(webpack中一切都是模块)，来作为构建其内部依赖图的开始。webpack可以通过入口，加载整个项目依赖 2.Output：出口 打包后，输出的文件目录 3.Loader：加载器 loader让webpack能够去处理那些非JavaScript文件(webpack自身只能解析JavaScript) 4.plugins：插件 实现loader之外的其他功能(打包优化和压缩等) 5.Mode：模式 生产模式production 开发模式development Vue面试题———————————————————————————————————————vue的优点是什么低耦合，可复用，独立开发，可测试 v-if和v-show的区别v-if为false的时候，是直接销毁的，v-show为false的时候结构还在只是通过样式来隐藏掉不占位，v-if为true的时候需要重新创建标签对象，v-show只需要修改样式显示出来就可以，v-show重新显示更快，但隐藏时还占用着内存空间，是以空间换时间的做法，如果需要频繁切换并且DOM结构比较大的话，使用v-show更好，v-if解决模板中初始解析undefined的bug computed和watch的区别1.计算属性必须同步返回计算结果，而watch中可以在异步操作后更新数据显示 2.watch可以深度监视，计算属性只是监视了使用到的数据 3.computed能实现的watch也能实现，而watch能实现的，computed不一定能实现 使用的选择： 1.如果是根据已有的数据同步计算出一个新的数据用computed 2.如果涉及到异步操作或深度监视用watch 3.一旦数据发生变化，需要做一系列的操作用watch computed和watch最大的区别，是在于computed的get和watch，跟set没关系。computed是需要同步返回数据的，watch不需要返回数据，因此可以异步进行赋值，所以computed内部不能有异步 computed和methods的区别computed有缓存机制，多次读取显示只计算了一次，methods没有缓存，多处显示计算多次 v-for和v-if能不能一起使用可以一起使用但是不推荐，这里有两种情况： 1.对遍历的数据进行限制判断，如果使用v-if，每个数组元素都会解析指令来判断导致效率低，解决办法是不使用v-if，使用computed，过滤产生一个子数组 2.对当前标签使用v-if限制是否显示或隐藏，会执行n次导致效率低，解决办法是将v-if添加在父标签上进行使用只执行一次 vue组件的生命周期创建阶段 特点： beforeCreate：创建前可以打印到this但是打印不到数据 created:创建后可以打印到this也可以打印到数据 他们之间做数据代理和数据劫持 其实创建阶段和挂载阶段统称为初始化阶段 他们之间其实还做了模板解析 挂载阶段 特点： beforeMount:挂载前拿不到真实的DOM元素 mounted:挂载后可以拿到真实的DOM元素 他们之间把虚拟DOM变为真实DOM 更新阶段 数据必须有更新才能进入这个阶段，并且可以多次进入 beforeUpdata：数据更新后，页面更新前，data的数据是一定更新了，页面的数据是没有更新的 updated:数据更新后，页面更新后，data的数据是一定更新了，页面的数据也更新了 销毁阶段 必须调用vm.destroy() 或页面刷新 页面关闭 v-if等才能进入销毁阶段 beforeDestroy：销毁前我们一般都是在这个钩子当中进行善后处理：比如清除定时器，解绑事件等等 destroyed:销毁后，其实就已经做不了什么了 keep-alive(缓存组件)会产生两个生命周期钩子 deactivated：组件失活，但是没有死亡 activated：组件激活，被复用 子组件执行抛出错误 errorCaptured:用于捕获子组件的错误，return false可以阻止错误向上冒泡 组件深入1.动态组件 特点： 通过动态确定要显示的组件，:is指定要显示组件的组件名 is属性初始为A组件名，加载A组件，切换为B组件名，加载B组件，当A组件切换到B组件时，A组件是被销毁 2.缓存组件 特点： 默认路由组件离开或动态组件被切换，组件都会立即死亡 keep-alive能让原本要死亡的组件不死亡，使其缓存起来，后面需要时，直接使用缓存 可以通过include与exclude属性来控制那些组件要缓存或不缓存 3.异步组件 特点： 在引入组件时使用import动态引入：const Home = () =&gt; import(&quot;./Home.vue&quot;) 组件会被单独打包，且只有在第一次访问是才会请求加载对应的打包文件 ===&gt; 减小首次打包的文件体积 出来组件，其他模块也可以异步加载，比如路由懒加载和图片懒加载 vue2组件间通信方式父子间 1. props =&gt; 父向子 / 子向父 2. vue自定义事件 =&gt; 子向父 3. v-model =&gt; 父子间(数据双向同步) 4. .sync =&gt; 子向父 5. $refs,$children =&gt; 父向子 6. $parent =&gt; 子向父 7. 插槽 / 作用域插槽 =&gt; 父向子(标签) / 子向父(数据) 祖孙间 8. $attrs与$listeners =&gt; 祖向孙 / 孙向祖 v-bind / v-on 9. provide与inject =&gt; 祖向孙 / 孙向祖 兄弟或其它/任意 10. 全局事件总线 11. Vuex 作用域插槽vue3组件间通信方式父子间 1. props =&gt; 父向子 / 子向父 2. vue自定义事件 =&gt; 子向父 3. v-model =&gt; 父子间(数据双向同步) 4. $refs,$children =&gt; 父向子 5. 插槽 / 作用域插槽 =&gt; 父向子(标签) / 子向父(数据) 祖孙间 6. $attrs与$listeners =&gt; 祖向孙 / 孙向祖 v-bind / v-on 7. provide与inject =&gt; 祖向孙 / 孙向祖 兄弟或其它/任意 8. Pubsub v3用不了 因为v3没有this 9. pinia 10. Vuex vue3也可以用vue2 区别MVVM与MVCMVVM：前台的技术 M： Model模型, 也就是包含数据的js对象 ==&gt; data对象 V： View视图，动态显示模型对象中的数据的页面(前台渲染) ==&gt; 模板页面 VM： ViewModel视图模型, 通过vm读取model中的数据显示到view上, 同时view输入数据改变, vm也可以将输入数据保存到model中 ==&gt; Vue/组件的实例 MVC：后台的技术 M: Model（模型）包含从数据库中查询得到的数据的对象 V: View（视图）动态显示模型对象中的数据的页面(后台渲染) C: Controller（控制器）接收用户提交的请求参数, 操作数据库生成动态数据并产生模型对象 vue响应式数据原理vue2的响应式数据原理有两种情况：对象和数组两种情况 对象:通过Object.defineProperty()添加setter方法来监视属性数据的改变 + 订阅-发布模式，Object.defineProperty在vm身上添加和data当中同名的属性，访问vm身上的属性会调用getter方法,返回的其实是data中的同名属性值，修改vm身上的属性会调用setter方法,修改的其实是data中的同名属性数据。 数据监视/劫持： 做了两件事： 1.根据data中的属性，对应都创建一个dep对象 2.会把data当中的数据变为响应式数据，原理还是添加getter和setter方法 数据劫持/监视是通过Object.defineProperty对data所有的属性修改响应式（添加getter和setter），如果访问data里面的属性，就会调用getter方法,返回属性值，如果修改data里面的属性值，就会调用setter方法，修改属性值。、 setter内部其实做了三个事 1、修改自己的数据 2、把修改的新数据也递归调用变为响应式 3、通知页面去修改数据 数组：重写更新数组元素的一系列方法 + 订阅-发布模式 数组方法有： push pop shift unshift splice sort reverse 7个方法 vue3的响应式数据原理核心是通过es6的新特性proxy代理，拦截对data任意属性的任意操作 vue双向数据绑定通过v-model来实现双向数据绑定，一般是作用在表单元素上面 v-model的本质是将动态的data数据通过“:value”属性传给input显示 ==&gt; data到view的绑定 给input标签绑定“@input”监听，一旦输入改变读取最新的值保存到data对应的属性上 ==&gt; view到data的绑定 双向数据绑定是在单向数据(data ---&gt; view)的基础，加入input事件监听(view ---&gt; data) nextTick原理在vue中数据是同步更新的，而DOM页面的更新是异步的，如果想要在数据更新后，立即获取更新后的DOM，则就需要使用nextTick方法中的回调函数获取，但是nextTick的回调函数也是异步的这时就要保证nextTick的回调函数是在页面DOM更新后再执行，否则就无法获取最新的DOM元素 ​ 但是怎么保证这个异步代码的执行顺序问题呢： vue内部中维护有两个队列，一个是(全局)queue队列和一个callbacks队列，使用nextTick方法可以将它的回调函数放入callbacks队列 其中queue里面存储是watcher的队列，watcher用来更新dom的，这个队列会有一个专门的函数用来遍历queue队列里面所有的watcher，然后会有一个queueWatcher函数调用nextTick方法将这个函数放入callback队列最前面 callbacks队列里则是存放的都是nextTick方法中的回调函数，所以他里面也可能会有多个回调函数，同时他也定义了一个函数，这个函数会遍历callback队列里面的所有回调函数依次执行，最后将这个函数根据情况放入宏任务或者微任务队列中执行，优先放入微任务队列，因为微任务性能更好","categories":[],"tags":[]},{"title":"less笔记","slug":"less","date":"2022-04-19T01:24:16.426Z","updated":"2022-04-19T01:27:53.211Z","comments":true,"path":"2022/04/19/less/","link":"","permalink":"http://example.com/2022/04/19/less/","excerpt":"","text":"less常用的方法、ps：在less中分号是很重要的。 一、变量多次重复相同的值，通常在您的样式表中可看到。不用多次使用相同的值，可以使用变量。它使代码的维护更容易，并且可以从单个位置控制这些值。 变量作为样式的值使用 123456@w:100px;#div &#123; width: @w; height: @w; background-color: aqua;&#125; 变量作为变量的名字--@{变量名} 1234567@bg : background;#bg&#123; width: 300px; height: 300px; @&#123;bg&#125;: red; margin: auto;&#125; 变量作为选择器使用--@{选择器} 123456@w:#div;@&#123;w&#125; &#123; width: 300px; height: 300px; background-color: red;&#125; 变量作为url地址 123456789101112131415161718@img1:&#x27;https://www.baidu.com/img/flexible/logo/pc/result@2.png&#x27;;@img2:url(&#x27;https://www.baidu.com/img/flexible/logo/pc/result@2.png&#x27;);@img3:@img2;#outer &#123; width: 300px; height: 300px; background-color: aqua; margin: auto; position: absolute; left: 0; top: 0; bottom: 0; right: 0; // background:url(@img1) 0 0 no-repeat; // background: @img2 0 0 no-repeat; background: @img3 0 0 no-repeat;&#125; 变量的计算 12345678910111213@v:0;@z:@v + 2;#outer &#123; width: 300px; height: 300px; background-color: aqua; margin: auto; position: absolute; left: @v; top: @v; bottom: @v; right: @z;&#125; 二、嵌套​ 在使用标准CSS时，要为多层嵌套的元素定义样式，要么使用后代选择器从外到内的嵌套定义，要么给这个元素加上类名或 id 来定义。这样的写法虽然很好理解，但维护起来很不方便，因为无法清晰了解到样式之间的关系。 在Less中，嵌套规则使这个问题迎刃而解。嵌套规则允许在一个选择器中嵌套另一个选择器，这更容易设计出精简的代码，并且样式之间的关系一目了然。 123456789101112131415body&#123; background-color: red; .header&#123; height: 100px; background-color: yellow; &#125; .con&#123; margin: 0 auto; border: 1px solid green; &#125; .footer&#123; width: 1200px; box-shadow: 0px 0px 0px 0px #ccc; &#125; &#125; 使用&amp;：代表前边的所有父级元素，常用在伪元素 伪类 css结构类等需求上 内层选择器前面的 &amp; 符号就表示对父选择器的引用。在一个内层选择器的前面，如果没有 &amp; 符号，则它被解析为父选择器的后代；如果有 &amp; 符号，它就被解析为父元素。 123456789101112ul&#123; li&#123; line-height: 40px; &amp;:nth-child(1)&#123; line-height: 80px; &#125; &#125; li:nth-child(1)&#123; line-height: 80px; &#125;&#125; 三、less混合混合是一种将一组属性从一个规则集包含或混入到另一个规则集的方法。 简单一点来说，其实混合就有点类似编程语言中的函数，通过这种方式，可以在代码中实现复用。 12345678.s1 &#123; font-size: 14px; color: #ccc;&#125;.s2 &#123; .s1;//注意没有加（），如果加了相当于是函数调用 padding: 10px;&#125; 在声明混合的时候，可以在小括号中声明形参。形参由@+变量名定义。调用的时候可以传入实参 如果很多的位置都需要使用某一个Mixins，而且参数还不一样的话，那么就可以使用参数的Mixins 12345678.s1(@f,@c)&#123; font-size: @f; color: @c; &#125;.s2&#123; .s1(14px,red);//这里是实参 padding: 10px; &#125; 可以直接在混合中定义形参的时候，给形参设置默认值，比如（@color:red），当使用混合的时候，如果有实参传递，则使用实参的值，否则使用形参的默认值 123456789.s1(@f:10px,@c:red)&#123; font-size: @f; color: @c; &#125; .s2&#123; .s1();//这里的小括号内是实参，如果没有实参的话，就会用变量默认值 padding: 10px;&#125; Mixins命名空间 Less 中也有命名空间的概念，命名空间用于在通用名称下对 Mixins 进行分组，使用命名空间可以避免名称冲突，并从外部封装 Mixins 组。例如可以将类选择器或者ID选择器作为一个命名空间，然后将 Mixins 放在命名空间中，这样可以避免与引入的其他文件造成冲突 套一层外套。 12345678910111213.name_space&#123; .s1()&#123; font-size: 12px; &#125; &#125; .s2&#123; //五种 // .name_space &gt; .s1(); // 引用 以下哪种方式都可以 // .name_space.s1; // .name_space.s1(); // .name_space .s1; .name_space .s1(); &#125; !important关键字 !important 关键字用于覆盖特定属性。如果我们在 Mixins 引用后面加上 !important 关键字，则会将 Mixins 中的所有属性标记为 !important 。 1234567.mixin()&#123; color: red;&#125;h1&#123; color: #ccc; .mixin() !important;&#125; 匹配模式 在Less中尝试利用模式匹配替if&#x2F;else，其执行原理类似switch&#x2F;case。 因为一个混合可能有多种形式，所以Less提供了一种机制，允许根据参数的值来改变 mixin的行为。 其中当参数是@_开头的，是调用此混合必选的。 1234567891011121314151617//模式匹配中，公有的样式混合 需要书写@_做为参数.main(@_) &#123; width: 100px; height: 100px;&#125;.main(color1) &#123; background-color: pink;&#125;.main(color2) &#123; background-color: yellow;&#125;.outer &#123; .main(color1)&#125; 重载 相同的混合，不同的行为，可以根据调用的时候传入的实参个数选择匹配的混合内容 12345678910111213.main(@w) &#123; width: @w;&#125;.main(@w, @h) &#123; width: @w; height: @h;&#125;.outer &#123; //重载：根据参数个数不同，来匹配不同的混合 .main(100px, 100px)&#125; 根据判断条件选中Mixin的行为 类似于JavaScript的if&#x2F;else，使用when语法 Guards 允许我们使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;,关键字true（只匹配关键字true，非true不会匹配）， 支持逻辑and 和逗号（或者）以及not () 同时我们可以使用“，”分割多个Guards，其表示只要其中任意一个满足就为true 就是判断条件 12345678910111213.main(@a) when(@a&gt;30) &#123;//如果传入的实参大于30就走这个 width: 100px; height: 100px;&#125;.main(@a) when(@a&lt;=30) &#123;//如果传入的实参小于等于30就走这个 width: 200px; height: 200px;&#125;.outer &#123; .main(30)&#125; 也可以加and关键字来进行连接判断 1234567891011121314151617.main(@w) when(@w&gt;1000),(@w&lt;200) &#123; width:~&quot;@&#123;w&#125;px&quot;; height: 100px;&#125;.main(@w) when(@w&lt;=1000) and (@w&gt;=200) &#123; width:~&quot;@&#123;w&#125;px&quot;; height: 50px;&#125;.main(@b) when(not(@b&lt;=30))&#123; background: red;&#125;.outer &#123; .main(3000)&#125;","categories":[],"tags":[]},{"title":"JQuery笔记","slug":"jQuery","date":"2022-04-15T10:54:36.622Z","updated":"2022-04-19T01:21:59.277Z","comments":true,"path":"2022/04/15/jQuery/","link":"","permalink":"http://example.com/2022/04/15/jQuery/","excerpt":"","text":"一、JQuery​ 干什么: 一个优秀的js函数库，官网：http://jquery.com/ ​ jQuery简介： ​ * 是在2006年,美国人约翰创建的,jquery是一个js的文件 \\* 目的:因为以后工作中,会有一些老项目,就是用jquery来编写的,jquery可以认 \\* 为是前端人员必会的,学习它也是为了让我们更好的理解js,可以把经历放在项目 ​ * 的业务逻辑上,而不用过多的操心兼容性问题,jq可以解决95%兼容性问题 ​ * Why? * HTML元素选取(选择器) ​ * HTML元素操作 ​ * CSS操作 ​ * HTML事件处理 ​ * 链式调用 （重点） ​ * 读写合一 （重点） ​ * How? ​ * 1.引入jQuery库 ​ * 2.使用jQuery: jQuery核心函数 jQuery核心对象 ​ * 3.区别2种js库文件: 开发版(源码版) 生产版(压缩版) ​ * 4.区别2种引用js库的方式: 服务器本地库 ​ * CDN远程库 https://www.bootcdn.cn/ ​ jQuery的优点： ​ 使用简单方便 – 宗旨：Write Less, Do More。写得少，做得多。吃得少干得多。 ​ jQuery能做的js能做，js能做的jQuery也能做， ​ 但是jquery简单、易懂、兼容性好（解决了几乎所有的兼容性问题）。 ​ 链式编程 ​ 隐式迭代(隐式遍历):可以不用循环遍历对dom操作 ​ 读写合一 跟原生比： 原生版 需要将所有的dom元素以及相关的资源（img、css、js、font、音频、视频…）全部加载完毕之后才来执行的事件回调函数 window.onload &#x3D; function () {} jQuery版 只需要将所有的dom元素加载完毕之后就会执行这个函数 $(function () {}） 123456789101112131415// $一定是一个函数// $() fun()// $(function()&#123;&#125;) //fun(function()&#123;&#125;) function()&#123;&#125;是作为$这个函数的实参，也是回调函数// $(&#x27;#btn2&#x27;) 返回结果：元素对象// $(&#x27;#btn2&#x27;).click 这个元素对象中一定有一个属性叫click// $(&#x27;#btn2&#x27;).click() 证明click属性的值一定是一个函数// $(&#x27;#btn2&#x27;).click(function()&#123;&#125;) function()&#123;&#125;是作为函数的实参// 立即执行函数// (function () &#123;&#125;)(); 二、jQuery的两把利器1、jQuery核心函数 * 简称: jQuery函数($&#x2F;jQuery) * jQuery库向外直接暴露的就是$&#x2F;jQuery 暴露数据如果是直接暴露的，那么使用的时候直接使用即可。 * 引入jQuery库后, 直接使用$即可 * 当函数用: $(xxx) * 当对象用: $.xxx() 2、jQuery核心对象 * 简称: jQuery对象 * 得到jQuery对象: 执行jQuery函数返回的就是jQuery对象 * 使用jQuery对象: $(‘选择器对象’).css() 作为一般函数调用：$(param)1.参数为函数：当DOM加载完成后，执行此回调函数，window.onload和$(function(){}) 两个方式对比，是jq执行速度快 2.参数为选择器字符串：查找所有匹配的标签，并将他们封装成jQuery对象。$(“选择器”) 3.参数为DOM对象：将DOM对象封装成jQuery对象。$(dom对象)（括号内不用加引号） 4.参数为html标签字符串（用的少）：创建标签对象并封装成jQuery对象 5.js和jq可以共存在一个页面上，但是不能混用在一行代码上 6.伪数组，其实是对象！！jq对象一般都是伪数组 1234567//jq中没有自己的this指向，还是使用的js中的this指向console.log(this); //如果返回来的是标签本身，那么这个对象就是dom对象如何将dom对象转换成响应的jq对象console.log($(this)); //伪数组console.log(typeof $(this)); //object 作为对象使用：$.xxx()1.JQuery对象是一个包含所有匹配的任意多个dom元素的伪数组对象 2.基本行为： ​ size()&#x2F;length: 包含DOM元素个数 ​ [index]&#x2F;get(index) ：得到对应位置的DOM元素 ​ each():遍历包含的所有DOM元素 ps：each既可以遍历数组、对象、还可以遍历DOM元素对象 1.如果是数组或普通对象：$.each(对象名，function（下标，值）{})（下标和键名不能省略） 1234567891011121314151617181920212223var arr2 = [ [1,2,3], [4,5,6], [7,8,9]]$.each(arr2,function(index,item)&#123; $.each(item,function(i,v)&#123; console.log(v); &#125;)&#125;var obj = &#123; name:&#x27;刚哥&#x27;, age:45&#125;$.each(obj,function(key,value)&#123; //key表示的对象的键名 // console.log(key); //value表示的对象的键值 console.log(value);&#125;) 2.如果是DOM对象：$(“选择器对象”).each(function(下标,值){})（下标不能省略） 123456789$(&#x27;button&#x27;).each(function(index,value)&#123; //下标 // console.log(index); //元素对象 // console.log(value); //jq对象 // console.log($(value)); console.log($(value).html());&#125;) 三、常用属性1、操作任意属性 attr()：读写合一 如果传递的是一个参数：读，相当于getAttribute 如果传递的是二个参数：写，相当于setAttribute ps：attr设置的属性值如果之前存在的话，则默认是覆盖，一般设置普通属性，也可以设置自定义属性（$(‘button’).attr(‘abc’,100)） removeAttr()：移除属性 prop()：一般操作属性如果是布尔值之类的属性，则使用prop方法 复选框、单选按钮、下拉列表、readonly、disabled 一般主要针对于的是选中类的属性的设置 2、操作class属性 addClass()： 添加类名 removeClass()：移除类名 3、操作HTML代码&#x2F;文本&#x2F;值 html()：读写合一，括号为空就是读，写的话在括号内加，记得加引号 val()（获取输入框的值，表单用） 4、在jQuery对象中的元素对象数组中过滤出一部分元素来 \\1. first()：第一个元素 \\2. last()：最后一个元素 \\3. eq(index|-index) ：匹配元素的集合为指定的索引的哪一个元素。 \\4. filter(selector)：过滤出需要的元素 \\5. not(selector)：找到不为xxxx的元素 5、查找子、父、兄弟标签 children(): 获得匹配元素集合中元素的子元素，然后选择器选择性筛选 find()：通过一个选择器，jQuery对象，得到当前匹配的元素集合中每个元素的后代，不区分层级 parent()&#x2F;parents():找上一级父标签&#x2F;找所有父标签 prevAll()&#x2F;prev(): ：查找所有符合选择器或符合参数前面的标签&#x2F;prev方法就不要添加参数了，因为加了这个参数要严格了，有可能布局发送了变化，就影响了 “+” 是前面标签的下一个兄弟标签 console.log($(‘li#cc + ‘)); “~” 是前面标签下所有兄弟标签 console.log($(‘li#cc ~ li’)); siblings()：是获取所有除自己以外的兄弟标签，不分前后 toggleClass()：开关样式，你有我删，你没有我加 append():&#x2F;appendTo():内部默认追加在后 prepend()&#x2F;prependTo() ： 内部默认追加在前 Before()&#x2F;insertBefore(): 外部默认追加在前 after()&#x2F;insertAfter(): 外部默认追加在后 replaceWith()&#x2F;replaceAll():新all旧，旧with新 remove():不添加参数移除所有 empty();是将这个父元素中的所有的普通文本以及子元素全部删除掉 四、元素的尺寸1234567891. 内容尺寸 content-box height(): height width(): width2. 内部尺寸 content-box + padding-box innerHeight(): height+padding innerWidth(): width+padding3. 外部尺寸 content-box + padding-box + border-box outerHeight(false/true): height+padding+border 如果是true, 加上margin outerWidth(false/true): width+padding+border 如果是true, 加上margin","categories":[],"tags":[]},{"title":"Js高级","slug":"js高级","date":"2022-04-10T16:01:09.574Z","updated":"2022-04-19T01:22:23.928Z","comments":true,"path":"2022/04/11/js高级/","link":"","permalink":"http://example.com/2022/04/11/js%E9%AB%98%E7%BA%A7/","excerpt":"","text":"一、选择排序最主要的就是内层循环的时候，是由i+1开始 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [12, 44, 56, 21, 42, 32] for(i = 0;i &lt; arr.length - 1; i++)&#123; for(j = i + 1; j &lt; arr.length;j++)&#123; if(arr[i] &gt; arr[j])&#123; var temp = arr[i] arr[i] = arr[j] arr[j] = temp &#125; &#125; &#125; console.log(arr); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、快速排序采用的递归的方法，需要注意的是，每一次都会把左边或右边的新数组进行重新比较然后再排序，然后要设计好出口，不然会一直循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [83, 66, 74, 32, 55, 12, 23, 45] // 递归函数的出口 function quickSort(array) &#123; if(array.length &lt;= 1)&#123; return array &#125; // 1.先找基准值（数组长度折半），下标 var index = Math.ceil(array.length / 2) console.log(index); // 2.删除数组中的基准值 var value = array.splice(index,1)[0] console.log(value); var left = [] var right = [] console.log(array); // 3.遍历现在的array数组 for(var i = 0;i &lt; array.length; i++)&#123; if(array[i] &lt; value)&#123; //放进左边数组 left.push(array[i]) &#125;else&#123; //放进右边的数组 right.push(array[i]) &#125; &#125; //4.合并成一个新的结构 // 小 + 中 + 大 //在函数的内部调用自身函数的意义就在于函数内部的代码循环利用 console.log(left); console.log(right); return quickSort(left).concat(value,quickSort(right)) &#125; //调用函数 console.log(quickSort(arr)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三、浅拷贝和深拷贝拷贝：发生在数组和对象中 其实不管是深拷贝还是浅拷贝，只要赋值的元素值是引用数据类型，则修改一方是会影响另一方 浅拷贝：地址的传递，只要是同一个地址值，无论修改了那一方，另一方都会受影响，你改我也改 1、浅拷贝的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1.对象和数组两个类型放在一个函数中做浅拷贝 // 2.考虑到原变量的数据类型是不是需要做浅拷贝的对象和数组 // 如果是对象/数组 // 如果是对象，创建一个同类型的变量&#123;&#125; // 如果是数组，创建一个同类型的变量[] // 3.再将原数组/原对象，里面的数据依此拷贝到新变量里面 // 定义数据 var arr = [1,2,3,4,[10,20,30]] var obj1 = &#123;a:100&#125; // 定义函数 function shallowCopy(obj) &#123; //先考虑类型 // typeof instanceof检测数据的方法 if(typeof obj != &quot;object&quot;)&#123; return &#125; //判断obj传入的到底是数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125; //将原变量的值依此拷贝到新变量里面（遍历拷贝） for (var key in obj) &#123; //⑥ 在遍历的时候需要考虑到原变量中是否有数据,如果没有数据就不需要拷贝了 //对象原型身上一个方法：用来检测这个数组/对象中是否有下标/键名 //如果有则返回true；否则返回false //hasOwnProperty if(obj.hasOwnProperty(key))&#123; newObj[key] = obj[key] // 地址 &#125; &#125; return newObj &#125; //③ 调用函数 var newArr = shallowCopy(arr); newArr[4][0] = 100; console.log(newArr); console.log(arr); /* newArr[0] = 10; console.log(arr); console.log(newArr); */ /* var obj2 = shallowCopy(obj1); obj2.a = 200; console.log(obj1); console.log(obj2); */ // console.log(Object.prototype); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、深拷贝：修改其中数组的下标值，看另一个数组对应下标的值是否会变化 1、深拷贝–slice和concat方法12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--使用slice和concat slice：截取 slice形成的是一个新数组，不会影响原数组的结构 concat:合并 --&gt; &lt;script&gt; // var arr = [1,2,3,4,5]; // var newArr = arr.slice(0); // newArr[0] = 100; // console.log(newArr); // console.log(arr); // var arr = [1,2,3,4,5]; // var newArr = arr.concat(); // arr[0] = 100; // console.log(newArr); // console.log(arr); //其实不管是深拷贝还是浅拷贝，只要赋值的元素值是引用数据类型，则修改一方是会影响另一方 var arr = [ &#123; str: &#x27;hello&#x27; &#125;, [&#x27;old&#x27;] ] var newArr = arr.slice(0); arr[0].str = &quot;world&quot;; newArr[1][0] = &quot;new&quot;; console.log(arr); console.log(newArr); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、深拷贝的JSON方法1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [&#x27;old&#x27;,1,true,[&#x27;old1&#x27;,&#x27;old2&#x27;],&#123;old:1&#125;] //将数组对象转换成相应的字符串 var str = JSON.stringify(arr) // //按照这样的字符串转换成相应的对象 var newArr = JSON.parse(str)// // 注意：只有遍历赋值的时候是基本数据类型你改了我不改，引用数据类型你改了我也改 // 但是如果通过JSON字符串的方法再次转换成对象的话，则即使是引用数据类型也不会是你改我也改 newArr[0] = &quot;new&quot; newArr[3][0] = &quot;old3&quot; console.log(arr); console.log(newArr); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、深拷贝封装好的通用方法123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var obj = [&#123;&#x27;a&#x27;:&#123;&#x27;a1&#x27;:[&#x27;a11&#x27;,&#x27;a12&#x27;],&#x27;a2&#x27;:1&#125;,&#x27;b&#x27;:2&#125;,[&#x27;c&#x27;,&#123;&#x27;d&#x27;:4,&#x27;e&#x27;:5&#125;]] //1.准备一个函数 function DeepCopy(data)&#123; if(typeof data != &#x27;object&#x27;) return //创建一个变量，根据类型来进行创建 var newObj = data instanceof Array?[] : &#123;&#125; //遍历原obj数组 for(var key in data)&#123; //递归复制 if(data.hasOwnProperty(key))&#123; newObj[key] = typeof data[key] == &quot;object&quot; ? DeepCopy(data[key]) : data[key] &#125; &#125; return newObj &#125; var res = DeepCopy(obj) console.log(res); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、节流设置一个开关，如果上一次事件还没执行完，下一次就执行不了。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 节流是设置一个开关，先开进去之后再关，执行完之后再开 --&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; var ipt = document.querySelector(&#x27;input&#x27;) function handle()&#123; console.log(&quot;向服务器请求数据&quot;); &#125; var flag = true function debance()&#123; if(flag)&#123; flag = false setTimeout(function()&#123; handle() flag = true; &#125;,2000) &#125; &#125; ipt.addEventListener(&#x27;keyup&#x27;,debance) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、防抖每次请求都先清除上一次的定时器 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 防抖是每次请求先清除上一次的定时器 --&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; var ipt = document.querySelector(&#x27;input&#x27;) ipt.addEventListener(&quot;keyup&quot;,debance(handler.bind(ipt,10))) function handler()&#123; console.log(&quot;向服务器请求数据&quot;); console.log(this); &#125; function debance(a)&#123; var timer; return function()&#123; clearTimeout(timer) timer = setTimeout(function()&#123; a() &#125;,2000) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、闭包（就说是一种引用关系）闭包帮助我们解决在全局中也想要函数中的局部变量 ​ * 形成闭包函数的四个先决条件【必须都满足才可以】 ​ * 1. 外部函数必须要先调用 ​ * 2. 外部函数里面有内部函数的嵌套 ​ * 3. 内部函数需要作为外部函数的返回值 ​ * 4. 内部函数需要引用外部函数的变量（局部&#x2F;形参） 12345678910111213141516171819202122232425 function fun()&#123; var a = 1; var b = 2; function f1()&#123; a++; return a; &#125; return f1; &#125; var result = fun(); console.log(result);// result = null; //释放闭包这也是一个闭包函数/* function fun(a)&#123; return function()&#123; setTimeout(function()&#123; console.log(a); &#125;,3000) &#125; &#125; fun(); */ 七、修改this的指向（call，apply，bind）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- call和apply的区别：传递函数的实参形式上不同 函数对象.call(this指向,实参1,实参2...,实参n) 函数对象.apply(this指向,[实参1,实参2...,实参n]) call和bind的区别：是否会立即执行的问题 call和apply都是先修改this指向，然后就立即执行函数 bind先修改指向，返回的是当前函数体，可以自行选择调用位置 相同点：都可以修改this指向 --&gt; &lt;script&gt; /* var obj = &#123;&#125;; function f(x, y) &#123; console.log(x, y); // 1 2 console.log(this); //obj对象 &#125; // f.apply(obj, [1, 2]); f.call(obj, 1, 2); */ //看bind的使用 /* var obj = &#123;&#125;; function f() &#123; console.log(&quot;看我怎么调用&quot;); console.log(this); &#125; //修改this指向 var f1 = f.bind(obj); f1(); */ //有参数 /* function fn(a, b, c) &#123; console.log(a); console.log(b); console.log(c); &#125; var f = fn.bind(null,10); f(20,30); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、原型链有一张图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 初级原型链涉及的对象： 1.Student函数对象 2.Student函数的实例对象 3.Object函数对象 --&gt; &lt;script&gt; function Student(name)&#123; this.name = name; &#125; /* Student.prototype.study = function()&#123; console.log(&#x27;学习1&#x27;); &#125; */ Object.prototype.study = function()&#123; console.log(&#x27;学习2&#x27;); &#125; var s1 = new Student(&#x27;老王&#x27;); s1.study(); //关系链条： //1.函数即使不发生new，函数对象本身中也会存在prototype属性 //2.先有函数对象.prototype指向的那个对象中存在的数据，然后s1.__proto__也指向了那个对象 //如果反问咱们，想要给实例对象身上添加方法，给函数的显示原型对象身上添加 console.log(s1.__proto__ = Student.prototype); console.log(Student.prototype.__proto__ = Object.prototype); console.log(Object.prototype.__proto__); //null // console.dir(Student); // console.dir(Function.prototype); // console.log(Object.prototype.__proto__); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 九、方法的重载和重写重载：同一个方法会根据参数的不同来执行不同的业务逻辑，发生在一个类身上 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法重载：同一个方法会根据参数的不同来执行不同的业务逻辑 发生在一个类身上 --&gt; &lt;script&gt; function Student(name)&#123; this.name = name; &#125; Student.prototype.eat = function(address,who)&#123; console.log(&#x27;和&#x27;+who + &#x27;在&#x27;+address + &#x27;吃饭&#x27;); &#125; var s1 = new Student(); //在实例对象调用同一个方法的时候，通过传递不同的参数，达到不同的效果 s1.eat(&#x27;大街上&#x27;,&#x27;小姐姐&#x27;,); s1.eat(&#x27;咖啡馆&#x27;,&#x27;小哥哥&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 重写：和父类同名方法功能不同，被称作方法重写，发生在两个类身上 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法重写：和父类同名方法功能不同，被称作方法重写 发生在两个类身上 --&gt; &lt;script&gt; function Person()&#123; this.eat = function()&#123; console.log(&#x27;吃饭&#x27;); &#125; &#125; function Student(name)&#123; this.name = name; Person.call(this) this.eat = function(address)&#123; console.log(this.name + &#x27;去&#x27;+address+&#x27;吃饭&#x27;); &#125; &#125; function Doctor(name)&#123; this.name = name; Person.call(this); this.eat = function(who)&#123; console.log(this.name + &#x27;和&#x27;+who+&#x27;吃饭&#x27;); &#125; &#125; var s1 = new Student(&#x27;王云飞&#x27;); s1.eat(&#x27;食堂&#x27;); var d1 = new Doctor(&#x27;老王&#x27;); d1.eat(&#x27;媳妇&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"BOM笔记","slug":"BOM笔记","date":"2022-04-10T15:16:51.995Z","updated":"2022-04-19T01:21:36.023Z","comments":true,"path":"2022/04/10/BOM笔记/","link":"","permalink":"http://example.com/2022/04/10/BOM%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、BOMBOM是 browser object model 的缩写，简称浏览器对象模型 ，提供了独立于内容而与浏览器窗口进行交互的对象； window对象，是JS的最顶层对象，其他的BOM对象都是window对象的属性 1、locationLocation 对象包含有关当前 URL 的信息。Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 拓展：URL 统一资源定位系统（uniform resource locator）的组成（了解） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* location对象 我们浏览器上的地址栏输入框 【注】它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能location对象中的属性: url 统一资源定位符(相当于快递包上的一个地址) 英文：protocol(协议):hostname(主机名)：port(端口号)/pathname(路径)?查询字符串(search)#锚点(hash) http://www.baidu.com:8080/code/xxx.html?username=xxx&amp;age=18#1 中文描述：协议://IP(域名):端口号/路径/?查询字符串#锚点 location.protocol file:本地磁盘文件访问 http: https:(证书认证协议) location.hostname 主机名 IP（在全球范围内找到你当前网络的地址） 域名 就是IP的别称 location.port 端口号（默认隐藏的） 【注】 是当前电脑中使用网络的软件，随机给他分配的一个编号 0~65535 hostname:port 可以直接定位到当前使用网络的程序 小细节： 浏览器 8080 http： 80 https 443 location.pathname 路径 location.search 查询字符串 格式有要求的： ?username=xxx&amp;age=18 location.hash 锚点 */ // alert(location.protocol); // alert(location.hostname); // alert(location.pathname); // alert(location)输出location对象 // alert(location.href)输出整个url /* location方法： location.assign(url) [注]在当前窗口跳转带这个url location.replace(url) [注]在当前窗口替换成新的url，不会产生历史记录 location.reload() [注]刷新当前窗口 location.reload(true) 不经过浏览器缓存强制从服务器重载 */ &lt;/script&gt; &lt;button onclick=&quot;location.assign(&#x27;https://www.baidu.com&#x27;)&quot;&gt;assign&lt;/button&gt; &lt;button onclick=&quot;location.replace(&#x27;https://www.baidu.com&#x27;)&quot;&gt;replace&lt;/button&gt; &lt;button onclick=&quot;location.reload(true)&quot;&gt;replace&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; location值得注意的属性是:12location.seach 获取到查询参数 location.hash 获取到哈希值location.href = &#x27;&#x27; 跳转页面 location.reload() 刷新页面 2、history（了解）浏览器的前进与后退12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; //history.back() 后退 history.forword() 前进 history.go() 0:刷新 1：前进 -1：后退 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、navigator （了解） 管着浏览器的版本内核信息。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(navigator ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、screen（了解）包含有关客户端显示屏幕的信息1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(screen); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、正则表达式（要验证什么就去百度查）推荐网址：https://blog.csdn.net/weixin_30378623/article/details/97499364?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164960505016780261965242%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164960505016780261965242&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-97499364.142^v7^pc_search_result_cache,157^v4^control&amp;utm_term=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%A4%A7%E5%85%A8&amp;spm=1018.2226.3001.4187 1、创建正则表达式的方式12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1、使用构造函数创建正则 var demo = new RegExp(/abc/) // 2、字面量的方式创建正则 var demo = /abc/ //使用正则 var reg = /a/ reg.test(&quot;a&quot;) reg.test(&#x27;&#x27;) //test 方法就是用来检测传入的字符串，是否包含在指定的规则中 //返回值一定是一个布尔值 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、正则的范围标识： [abc]：查找方括号内任意一个字符。 [^abc]：查找不在方括号内的字符。 [0-9]：查找从 0 至 9 范围内的数字，即查找数字。 [a-z]：查找从小写 a 到小写 z 范围内的字符，即查找小写字母。 [A-Z]：查找从大写 A 到大写 Z 范围内的字符，即查找大写字母。 [A-z]：查找从大写 A 到小写 z 范围内的字符，即所有大小写的字母。 3、正则的词量和边界以及修饰符123456// /^[]$/严格模式 ^以x开头 $边界符 &#123;&#125; 量词console.log(/^a&#123;2,5&#125;$/.test(&#x27;aaaaa&#x27;));// . 匹配任意字符，除了换行符，想用的话，加个斜杠转义 \\d 匹配任意数字，等价于[0--9] \\w 匹配字母数字及下划线//中文 [\\u4e00-\\u9fa5] 4、贪婪模式和非贪婪模式（了解）非贪婪模式只是多了一个问号 1234567//贪婪模式var str = &#x27;aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc&#x27;console.log(str.match(/&lt;div&gt;.*&lt;\\/div&gt;/));//非贪婪模式var str = &#x27;aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc&#x27;console.log(str.match(/&lt;div&gt;.*?&lt;\\/div&gt;/g));","categories":[],"tags":[]},{"title":"DOM笔记","slug":"DOM笔记","date":"2022-03-29T10:37:25.695Z","updated":"2022-04-11T11:20:11.376Z","comments":true,"path":"2022/03/29/DOM笔记/","link":"","permalink":"http://example.com/2022/03/29/DOM%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、DOM 的介绍1231.*当创建好一个页面并加载到浏览器时，DOM就悄然而生！！！，它会把网页文档（html页面）转换为一个文档对象，*主要功能是处理网页内容，dom就是操作页面中的元素！！！2.顶级对象是 document, 通过 document 提供的一系列方法能够获取到对应的元素，是一个DOM对象3.可以操作元素的样式、属性、内容 二、获取元素的方法、事件的格式1234567891011121314151617181920212223//只能获取唯一id的元素，所以不带“s”document.getElementById() //获取元素的类名，可以批量获取所以带“s”，获取的元素会被放置在一个伪数组中，不能调用forEach方法，但是有length属性document.getElementsByClassName() //通过标签名获取元素，可以批量获取所以带“s”，获取的元素会被放置在一个伪数组中，不能调用forEach方法，但是有length属性document.getElementsByTagName()//通过表单的name属性获取元素，可以批量获取所以带“s” 输出的类型为 - NodeList，一般只用于获取表单元素，能调用forEach方法，有length属性document.getElementsByName()//HTML5 更新的选择器，选择单个的元素，有兼容性问题，一定要加选择符document.querySelector()//获取更多的元素，一般用于获取类名或者标签名的元素，结果为多个，是NodeList结构，可以使用 forEach方法document.querySelectorAll()//获取HTMl节点document.documentElement//获取body节点documnet.body 123456789101112131415164.注册事件的格式是，事件源.事件 = 事件处理程序btn.onclick = function() &#123;&#125;// 批量注册事件 for(var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function() &#123; // code &#125;&#125;//数组的forEach方法遍历lis.forEach(function(el) &#123; el.onclick = function() &#123; &#125;&#125;) 12345678//注意事项选择器的新方法和旧方法，都只会呈现两种状态1. 通过 getElementById 或者 querySelector 直接获取的元素 可以对 DOM 对象直接操作，注册事件，操作样式...2. 通过其他方法获取的元素，由于是伪数组，并不能直接操作 要么使用下标索引的方式提取出来 boxs[i] 要么使用 for 循环或者 forEach 的方式遍历操作 三、事件的类型12345//鼠标事件1.onclick 单击 2.onndblclick 双击 3.onmousemove 鼠标移动4.onmouseover &amp;&amp; onmouseout 移入移出 //这个会有冒泡特性，所以一般用的少5.onmouseenter &amp;&amp; onmouseleave 移入移出 //这个没有冒泡特性6.onmousedown 鼠标按下 onmouseup 鼠标弹起 12345//键盘事件1.onkeydown 键盘按下 2.onkeyup 键盘弹起 3.onkeypress 键盘按压4.event.keyCode 键码//onkeydown 和 onkeypress 区别？onkeypress区分大小写，对应的键码会不一样，不识别系统按键 12//表单事件1.onfocus 获得焦点 2.onblur 失去焦点 3.oninput 输入事件 4.onchange 当内容改变 1234系统内置事件 window.onload = &#123;&#125;// 会等待body中的内容全部渲染完毕再会执行事件赋值的函数，不需要我们手动调用，是浏览器内部由window进行处理 1、案例：鼠标移入高亮显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; ul,li&#123; list-style: none; &#125; a&#123; text-decoration: none; &#125; .list&#123; width: 200px; height: 150px; border: 1px solid black; &#125; .list li&#123; width: 200px; height: 50px; background-color: hotpink; text-align: center; line-height: 50px; &#125; .list li:nth-child(2)&#123; border-top: 1px solid black; border-bottom: 1px solid black; box-sizing: border-box; &#125; .list li a&#123; font-size: 20px; color: white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;大哥的桂芬&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;大哥的秀琴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;大哥的诸葛钢铁&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var liNodes = document.querySelectorAll(&#x27;.list &gt; li&#x27;); for (var i = 0; i &lt; liNodes.length; i++) &#123; liNodes[i].onmouseover = function() &#123; this.style.backgroundColor = &#x27;red&#x27;; &#125;; liNodes[i].onmouseout = function() &#123; this.style.backgroundColor = &#x27;green&#x27;; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2、keyCode思考：如何区分按下的是哪个键，所以需要区分键 区分键位，我们需要通过键码(keyCode)去区分，每次触发事件时，都会在事件的回调函数中有一个事件对象(event)，事件对象就是回调函数的第一个参数，每一次触发事件时，系统会自定帮我们把这一次触发事件的相关信息封装为一个事件对象，系统会把这个事件对象传给回调函数的第一个形参 12345678910111213&lt;input type=&quot;text&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var inputNode = document.querySelector(&quot;input&quot;); inputNode.onkeyup = function(e) &#123; if (e.keyCode === 13) &#123; console.log(&quot;回车&quot;); &#125; else if (e.keyCode === 16) &#123; console.log(&quot;shift&quot;); &#125; &#125; &#125;&lt;/script&gt; 3、案例：全选、全不选、反选（***）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 300px; margin: 100px auto; &#125; ul &#123; list-style: none; &#125; li &#123; line-height: 40px; margin-bottom: 10px; &#125; .box-content &#123; margin-top: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-top&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot;&gt; 全选 &lt;button id=&quot;btn&quot;&gt;真正的反选&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;box-content&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //获取对应的元素 var checkAll = document.querySelector(&#x27;#checkAll&#x27;) var btn = document.querySelector(&#x27;#btn&#x27;) var box = document.querySelector(&#x27;.box-content&#x27;) // 获取底部盒子内的所以input var ipts = box.querySelectorAll(&#x27;input&#x27;) // 注册事件 全选和全不选,这个是全选和全不选按钮事件 checkAll.onclick = function() &#123; ipts.forEach(function(el)&#123; el.checked = checkAll.checked &#125;) &#125; //反选 ipts.forEach(function(el)&#123; el.onclick = function() &#123; //需要再给下面的5个复选框遍历，只要有一个未选中，就结束循环 // var bool = true // for(var i = 0;i &lt; ipts.length;i++)&#123; // // 取反 // if(!ipts[i].checked)&#123; // bool = false // break // &#125; // &#125; var arr = Array.of(ipts) var bool = arr.every(function(val)&#123; return val.checked &#125;) checkAll.checked = bool &#125; &#125;) btn.onclick = function() &#123; ipts.forEach(function(el) &#123; el.checked = !el.checked &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、批量注册事件&amp;&amp;排他思想（**）干掉所有人，留下我自己 12345678910111213141516171819202122232425// 排他思想第一步就是要操作所有的元素，那么就一定要遍历获取到的元素.forEach(function(el) &#123; el.onclick = function() &#123; //先把所有的元素样式去掉 排他思想 获取到的元素.forEach(function(item) &#123; item.style = &#x27;&#x27; &#125;) //当前的元素单独添加样式 el.style.color = &#x27;skyblue&#x27; &#125;&#125;)for (var i = 0; i &lt; 获取到的元素.length; i++) &#123; 获取到的元素[i].onclick = function () &#123; //先把所有的元素样式去掉 排他思想 for (var j = 0; j &lt; 获取到的元素.length; j++) &#123; 获取到的元素[j].className = &quot; &quot;; &#125; //当前的元素单独添加样式 this.className = this.className + &quot;active&quot;; &#125;&#125;1.在循环结束的后面，单独给自己设置样式2.获取到的元素[i] this el 都代表自身元素 1、案例：选项卡（***)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box button&#123; width: 80px; height: 40px; background-color: hotpink; color: #fff; margin-right: 25px; &#125; #box div&#123; width: 300px; height: 100px; background-color: aqua; &#125; .cls&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;button&gt;飞天&lt;/button&gt; &lt;button&gt;遁地&lt;/button&gt; &lt;button&gt;无所不能&lt;/button&gt; &lt;div&gt;sczd az ada&lt;/div&gt; &lt;div&gt;a cads axc &lt;/div&gt; &lt;div&gt; acasdf q&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var box = document.querySelector(&#x27;#box&#x27;) var btns = box.querySelectorAll(&#x27;button&#x27;) var Div = box.querySelectorAll(&#x27;div&#x27;) Div.forEach(function(el,index)&#123; el.onclick = function() &#123; btns.forEach(function(item,i)&#123; item.className = &quot; &quot; Div[i].style.display = &quot;none&quot; &#125;) el.className = &quot;cls&quot; Div[index].style.display = &quot;block&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、轮播图根据点的索引更改透明度（*）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, ol &#123; position: relative; list-style: none; &#125; body &#123; padding: 20px; &#125; ul li &#123; position: absolute; top: 0; left: 0; width: 300px; height: 200px; transition: all 0.3s ease-in; &#125; ul li:first-of-type &#123; z-index: 1; &#125; ul li img &#123; width: 100%; height: 100%; &#125; ol &#123; z-index: 999; display: flex; &#125; ol li &#123; width: 10px; height: 10px; background-color: #333; margin: 10px; border-radius: 50%; &#125; .cls &#123; background-color: #f8f8f8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/01.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/02.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/03.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/04.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class=&quot;cls&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; var ol = document.querySelector(&#x27;ol&#x27;) console.log(ol); var ollis = ol.querySelectorAll(&#x27;li&#x27;) console.log(ollis); var ul = document.querySelector(&#x27;ul&#x27;) console.log(ul); var ullist = ul.querySelectorAll(&#x27;li&#x27;) console.log(ullist); ollis.forEach(function(el,index)&#123; el.onmouseenter= function() &#123; ollis.forEach(function(item,i)&#123; item.className = &quot; &quot; ullist[i].style.opacity = 0 &#125;) this.className = &#x27;cls&#x27; console.log(this); ullist[index].style.opacity = 1 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、二级菜单（***）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; a &#123; text-decoration: none; color: #333; &#125; .content &#123; margin: 100px auto; padding: 20px 120px; background-color: #ccc; &#125; .nav &#123; display: flex; &#125; .nav li &#123; position: relative; padding: 5px 10px; margin: 0 5px; background-color: #eee; &#125; .nav ul &#123; position: absolute; top: 30px; left: 0; display: none; &#125; /* .nav li:hover ul &#123; display: block; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;content&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第01项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第02项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第03项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第04项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第05项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var lis = document.querySelectorAll(&#x27;.nav &gt; li&#x27;) console.log(lis); lis.forEach(function(el)&#123; el.onmouseenter = function()&#123; lis.forEach(function(item)&#123; var ulbox = item.querySelector(&#x27;ul&#x27;) ulbox.style.display = &quot;none&quot; &#125;) var curul = el.querySelector(&#x27;ul&#x27;) curul.style.display = &quot;block&quot; &#125; el.onmouseleave = function()&#123; var curul = el.querySelector(&#x27;ul&#x27;) curul.style.display = &quot;none&quot; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、操作元素的样式、属性、内容操作样式：行内样式、类样式1234567891011121314行内样式：//操作DOM对象的行内样式获取的DOM对象.style.样式属性 = &#x27;值&#x27;// 如果样式属性中间有中横线，横杠后面的首字母拼接之后需要大写font-size =&gt; fontSize// 如果设置的样式为多个 box.style = &#x27;color: red; font-size: 30px;&#x27;类样式：//操作DOM对象的类样式获取的DOM对象.className = &#x27;&#x27;//赋值的类名，会覆盖原先的类名，如果都要实现样式，一定要在字符串中同时设置box.className = &#x27;demo cls&#x27;//ps:要添加的类名，一定是 css 样式表中提前声明好的类名 操作属性：Attribute（**）1234567891011//操作标签的属性 Attribute方法getAAttribute 获取属性值 setAttribute 设置属性和值 removeAttribute 移除属性//DOM元素的对象属性，操作DOM元素的对象属性和原始操作OBject的属性一样，使用打点或者中括号的方式console.dir()//可以展开DOM对象的详情1.早期，标签的自定义属性不会添加到dom对象中，dom对象中添加的属性，不会映射到标签上//HTML5 更新了一种格式，打破了这个规则2.只要是在标签中添加的 data- 开头的属性，会被写入到dom对象的 dataset 属性中3.只要是通过 DOM 对象设置的属性，会自动映射到标签的属性上，并且自动加上 data- 标识4.如果在标签上用了中横线，在获取的时候要写小驼峰，如果设置的js属性是小驼峰，会自动解析为中横线 操作内容：innerHTML、innerText、textContent、value（***）123456789101112操作内容：//可以获取和设置元素的内容innerHTML 和 innerText1.innerHTML 可以获取到标签，在设置的时候也会识别并渲染标签2.innerText 只会获取纯文本//innerText 和 textContent1.innerText 只会获取纯文本2.textContent 只有 IE8 以上才能识别和使用3.textContent 能获取隐藏元素的内容，并且保留内容的换行格式//value：表单属性,表单的内容是通过value获取的console.log(input.value) 1、案例：兼容性封装读写内容1123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;pp&quot;&gt;老马&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; //如果用户使用的是高级浏览器就自动的通过textContent去操作内容 //如果用户使用的是低级浏览器就自动的通过innerText去操作内容 var pNode = document.getElementById(&#x27;pp&#x27;); // console.log(pNode.textContent);不能直接写，因为这样只能满足高级浏览器的用户操作内容，低级浏览器不能 // console.log(getOrSetContent(pNode));//兼容性获取P内部的内容 getOrSetContent(pNode, &#x27;老马过河&#x27;); //兼容性设置p内部的内容 function getOrSetContent(node, content) &#123; if (arguments.length === 1) &#123; //在获取内容 if (node.textContent) &#123; //证明是高级 return node.textContent; &#125; else &#123; //低级浏览器 return node.innerText; &#125; &#125; else if (arguments.length === 2) &#123; //在设置内容 if (node.textContent) &#123; //证明是高级 node.textContent = content; &#125; else &#123; //低级浏览器 node.innerText = content; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2、案例：兼容性封装读写内容2（优化）1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;pp&quot;&gt;老马&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; //如果用户使用的是高级浏览器就自动的通过textContent去操作内容 //如果用户使用的是低级浏览器就自动的通过innerText去操作内容 var pNode = document.getElementById(&#x27;pp&#x27;); // console.log(pNode.textContent);不能直接写，因为这样只能满足高级浏览器的用户操作内容，低级浏览器不能 // console.log(getOrSetContent(pNode));//兼容性获取P内部的内容 getOrSetContent(pNode, &#x27;老马过河&#x27;); //兼容性设置p内部的内容 //函数优化 function getOrSetContent(node, content) &#123; if (arguments.length === 1) &#123; //在获取内容 // return node.textContent?node.textContent:node.innerText return node.textContent || node.innerText; &#125; else if (arguments.length === 2) &#123; //在设置内容 node.textContent ? node.textContent = content : node.innerText = content; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 六、节点操作1、什么是节点​ 什么是节点，节点的类型有哪些，我们需要学习哪些节点，节点的关系是什么样的。 ​ 在 DOM 树中，组成的最小单位就是节点 (Node)，当网页在浏览器中打开的时候，就会把所有的页面内容渲染成对应节点，每一个节点都会有 nodeType, nodeValue, nodeName 三个属性 ​ 节点一共有 12 种类型，还分别编号了，元素节点1，属性节点2，文本节点3，注释节点8 2、总结： nodeType nodeName nodeValue 元素节点 1 元素名大写 null 属性节点 2 属性名 属性值 文本节点 3 #text 文本内容 注释节点 8 #comment 注释内容 12345678910111.node.nodeType功能：返回节点类型，只读console.log(div,nodeType)2.node.nodeName功能：返回元素的标签名，以大写形式表示，只读consloe.log(div.nodeName);3.nodeValue功能：返回text或Comment（注释）节点的文本内容，可读写consloe.log(div.nodeValue); 3、创建和操作节点的方法12345678910111213141516171819202122232425262728293031323334获取元素只需要记住：children 子元素节点 parentNode 父节点 nextElementSibling 下一个兄弟元素节点 previousElementSibling 上一个兄弟元素节点//创建元素,有返回值，是一个dom对象，可以设置事件，赋值内容，但是不会立马在网页中呈现doucment.createElement(&#x27;标签名&#x27;)例：//createElement 创建元素var h2box = document.createElement(&quot;h2&quot;)h2box.innerText = &#x27;12345&#x27;//appendChild 追加节点app.appendChild(h2box)//删除box.removeChild() //删子元素，一定要传入要删除的那个节点box.remove() //删自己，不需要传参//添加父盒子.insertBefore(参数1，参数2)参数1：要添加的那个新节点参数2：参考父盒子内的指定子节点父盒子.appendChild(参数)参数：要添加的子节点，会在父盒子的队尾出现//替换父盒子.replaceChild(参数1，参数2)参数1：要替换的那个新节点参数2：在父盒子内要被替换的指定子节点//拓展 cloneNode()没有参数：只会克隆一层盒子有参数为true：会深层克隆整个盒子只克隆的话，不会在页面中同步出现 七、事件注册的 DOM2 方式（事件监听）绑定与解绑123456789101112131415box.addEventListener(&#x27;事件名称&#x27;， function() &#123; // 事件处理程序&#125;)// 如果你需要解绑，一定要把注册事件的回调函数写出来，并且命名box.removeEventListener(&#x27;事件名称&#x27;, 事件处理函数的名称)绑定事件函数this和绑定元素有关系，但是和实际可能操作的子元素无关box.addEventListener(&#x27;click&#x27;,function(event)&#123;//console.log(this)event.targetevent.srcElement&#125;,true) 捕获addEventListener(&#x27;click&#x27;,function()&#123;&#125;,false) 冒泡 1、注册事件的初级封装1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#x27;btn&#x27;) // //高级浏览器 // btn.addEventListener(&#x27;click&#x27;,function()&#123; // console.log(100); // &#125;) // //低级浏览器 // btn.attachEvent(&#x27;onclick&#x27;,function()&#123; // console.log(100); // &#125;) //封装的过程就是，把相同的部分放进一个函数，把不同的作为参数 function addE(el,type,fn)&#123; //事件源 注册事件的方法 事件的名称 if( el.addEventListener)&#123; el.addEventListener(type,fn) &#125;else&#123; el.attachEvent(&#x27;on&#x27; + type,fn) &#125; &#125; //封装之后的调用 addE(btn,&quot;click&quot;,function()&#123; console.log(100); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、注册事件的注意事项：注册事件监听的时候，参数2不允许提前调用 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; //注册事件监听的时候，参数2不允许提前调用 btn.addEventListener(&#x27;click&#x27;,function() &#123; fn(100) &#125;) function fn(n)&#123; console.log(n); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、事件流事件流描述的就是从页面中接收事件的顺序。而早期的IE和Netscape提出了完全相反的事件流概念，IE事件流是事件冒泡，而Netscape的事件流就是事件捕获。 12DOM2级事件规定的事件流包括三个阶段： （1）事件捕获阶段 （2）处于目标阶段 （3）事件冒泡阶段捕获---目标---冒泡 1、阻止事件冒泡那个目标元素的事件需要阻止就加入如下代码： 1event.stopPropagation(); // 专门用来阻止事件冒泡 九、事件委托干什么：事件委派过程当中依赖了事件冒泡 阻止事件冒泡，是为了解决冒泡给我们带来的困扰 事件冒泡的好处就是可以进行事件委派（事件委托，事件代理）；把子元素的事件监听添加给父（祖先）元素，把子元素发生的事件委托给父元素进行处理； 怎么用： 当一个元素内部儿子很多，并且每个儿子都要添加相同的事件的时候，我们可以使用事件委派来提高效率； 出现新添加的东西，并且新添加的东西要和老的拥有同样的行为；此时我们就想事件委派；不用事件委派，老的身上会有想要的行为，而新添加的没有； 用法：事件委托的第一种12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;这是第1&lt;/li&gt; &lt;li&gt;这是第2&lt;/li&gt; &lt;li&gt;这是第3&lt;/li&gt; &lt;li&gt;这是第4&lt;/li&gt; &lt;li&gt;这是第5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var lis = document.querySelectorAll(&#x27;li&#x27;) var ulbox = document.querySelector(&#x27;ul&#x27;) //批量注册事件 // lis.forEach(function(el)&#123; // el.onclick = function()&#123; // console.log(111); // &#125; // &#125;) ulbox.onclick = function(event)&#123; //event 事件对象 target目标元素 var curEl = event.target //只有当前元素是LI的时候，才会触发事件 nodeName 节点的名称(大写) if(curEl.nodeName = &quot;LI&quot;)&#123; console.log(curEl.innerText); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件委托的第二种123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;这是1&lt;/li&gt; &lt;li&gt;这是2&lt;/li&gt; &lt;li&gt;这是3&lt;/li&gt; &lt;li&gt;这是4&lt;/li&gt; &lt;li&gt;这是5&lt;/li&gt; &lt;/ul&gt; &lt;button id=&quot;btn&quot;&gt;点我添加新节点&lt;/button&gt; &lt;script&gt; var ulbox = document.querySelector(&#x27;ul&#x27;) var lis = ulbox.querySelectorAll(&#x27;li&#x27;) var btn = document.querySelector(&#x27;#btn&#x27;) btn.onclick = function()&#123; var newli = document.createElement(&#x27;li&#x27;) newli.textContent = &quot;这是新的节点&quot; ulbox.appendChild(newli) &#125; //事件源一定是父盒子，是页面中存在的盒子 ulbox.onclick = function(event)&#123; var curEl = event.target//通过它获取的是真正触发事件的那个元素 if(curEl.nodeName === &#x27;LI&#x27;)&#123;//根据节点名称去判断是否为想要的那个元素 console.log(curEl.innerText); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1、学员信息列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style&gt; table &#123; border: 1px solid #ccc; border-collapse: collapse; &#125; tr, td, th &#123; border: 1px solid #ccc; padding: 20px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;序号： &lt;input type=&quot;text&quot; id=&quot;a&quot;&gt;姓名： &lt;input type=&quot;text&quot; id=&quot;uname&quot;&gt;性别： &lt;input type=&quot;text&quot; id=&quot;gender&quot;&gt;年龄： &lt;input type=&quot;text&quot; id=&quot;age&quot;&gt;&lt;button id=&quot;btn&quot;&gt;添加学员&lt;/button&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;常盛瑞&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;王云飞&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script&gt; var dels = document.querySelectorAll(&#x27;tbody &gt; tr &gt; td &gt; a&#x27;) var tbody = document.querySelector(&#x27;tbody&#x27;) var btn = document.querySelector(&quot;#btn&quot;) dels.forEach(function(el)&#123; el.onclick = function()&#123; this.parentNode.parentNode.remove() &#125; &#125;) btn.addEventListener(&#x27;click&#x27;,function()&#123; var trbox = document.createElement(&#x27;tr&#x27;) var td1 = document.createElement(&#x27;td&#x27;) td1.textContent = a.value var td2 = document.createElement(&#x27;td&#x27;) td2.textContent = document.querySelector(&#x27;#uname&#x27;).value var td3 = document.createElement(&#x27;td&#x27;) td3.textContent = document.querySelector(&#x27;#gender&#x27;).value var td4 = document.createElement(&#x27;td&#x27;) td4.textContent = document.querySelector(&#x27;#age&#x27;).value var td5 = document.createElement(&#x27;td&#x27;) td5.innerHTML = &#x27;&lt;a href = &quot;#&quot;&gt;删除&lt;/a&gt;&#x27; trbox.appendChild(td1) trbox.appendChild(td2) trbox.appendChild(td3) trbox.appendChild(td4) trbox.appendChild(td5) tbody.appendChild(trbox) &#125;) tbody.addEventListener(&#x27;click&#x27;,function(event)&#123; if(event.target.nodeName === &quot;A&quot;)&#123; event.target.parentNode.parentNode.remove() &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、两种鼠标经过的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background: gray; line-height: 100px; text-align: center; margin:20px; padding: 50px; box-sizing: border-box; &#125; div span&#123; width: 100px; height: 100px; display: inline-block; background: white; &#125; &lt;/style&gt; &lt;script&gt; /* [注]经过子节点会重复触发 mouseover 鼠标移入 mouseout 鼠标移出 [注]经过子节点不会重复触发 IE8以后才有 mouseenter 鼠标移入 mouseleave 鼠标移出 */ window.onload = function ()&#123; var aDivs = document.getElementsByTagName(&quot;div&quot;); var i = 0; aDivs[0].onmouseover = function ()&#123; var oSpan = this.getElementsByTagName(&quot;span&quot;)[0]; oSpan.innerHTML = i++; &#125; var j = 0; aDivs[1].onmouseenter= function ()&#123; var oSpan = this.getElementsByTagName(&quot;span&quot;)[0]; oSpan.innerHTML = j++; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;mouseover&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;mouseenter&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十、鼠标坐标1、浏览器中查看鼠标坐标的三种方式123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; height: 2000px; &#125; body&#123; margin: 30px; padding: 20px; &#125; #box&#123; width: 300px; height: 300px; background-color: #ccc; margin: 20px; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;/div&gt; &lt;script&gt; window.onload = function()&#123; document.documentElement.onmousemove = function(event) &#123; //视口的坐标只会根据窗口计算，页面滚动跟它没关系 console.log(&#x27;基于视口的坐标:&#x27; + event.clientX + &#x27;,&#x27; + event.clientY); //页面的坐标跟页面的位置计算，不考虑视口的位置 console.log(&#x27;基于页面的坐标：&#x27; + event.pageX + &#x27;,&#x27; + event.pageY); //页面的坐标是基于当前触发事件的目标元素的左上角开始计算 console.log(&#x27;基于自身的距离：&#x27; + event.offsetX + &#x27;,&#x27; + event.offsetY); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、封装好的图片拖拽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin: 0;padding: 0;&#125; body&#123; background-color: #000; &#125; img&#123; position: fixed; top: 0; left: 0; width: 230px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img draggable=&quot;false&quot; src=&quot;../1.imgs/pc_activity_1_qcode.png&quot; alt=&quot;&quot;&gt; &lt;script&gt; //这是封装好的拖拽效果 var imgbox = document.querySelector(&#x27;img&#x27;) function limitDrag(node)&#123; node.onmousedown = function (ev)&#123; var e = ev || window.event;//window.event是兼容写法 //记录鼠标按下的位置和被拖拽物体相对距离 var offsetX = e.clientX - node.offsetLeft; var offsetY = e.clientY - node.offsetTop; // 一致保持相对位置，相对距离 document.onmousemove = function (ev)&#123; var e = ev || window.event; var l = e.clientX - offsetX; var t = e.clientY - offsetY; //限制出界 if(l &lt;= 0 )&#123; l = 0; &#125; var windowWidth = document.documentElement.clientWidth || document.body.clientWidth; if(l &gt;= windowWidth - node.offsetWidth)&#123; l = windowWidth - node.offsetWidth; &#125; if(t &lt;= 0)&#123; t = 0; &#125; var windowHight = document.documentElement.clientHeight || document.body.clientHeight; //这里不加的话 可以向下无限延伸 if(t &gt;= windowHight - node.offsetHeight)&#123; t = windowHight - node.offsetHeight; &#125; // 这里是图片拖动 node.style.left = l + &quot;px&quot; node.style.top = t + &quot;px&quot; &#125; &#125; //取消拖拽 document.onmouseup = function ()&#123; document.onmousemove = null; &#125; &#125; limitDrag(imgbox) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 盒子在浏览器中的尺寸三大系列：clicent系列、offset系列、scroll系列 1、clicent系列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; margin: 100px; width: 100px; height: 100px; background-color: red; border: 50px solid #333; padding: 50px; overflow: scroll; direction: rtl; &#125; .son &#123; height: 300px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1.0 获取元素 var box = document.querySelector(&#x27;.box&#x27;) // 2.0 直接获取元素的尺寸 client 系列 不包含 border 边框 console.log(box.clientHeight + &#x27;： 元素的高度&#x27;) // 183 height + 上padding + 下padding 如果有滚动条会减去滚动条的值 console.log(box.clientWidth + &#x27;： 元素的宽度&#x27;) //183 width + 左padding + 右padding console.log(box.clientTop + &#x27;： 元素的Top 就是 上边框的值&#x27;) //50 一般是单边的边框的值，如果有滚动条的话，是边框加滚动条的值 console.log(box.clientLeft + &#x27;： 元素的Left 左边框的值&#x27;)//67 一般是单边的边框的值，如果有滚动条的话，是边框加滚动条的值 // 其实 clinetLeft 获取的是边框和 滚动条的距离 // 只是平常不怎么使用而已 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、offset系列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body &#123; padding: 20px; border: 10px solid #ccc; margin: 10px; &#125; .box &#123; margin: 146px; width: 100px; height: 100px; background-color: red; border: 50px solid #333; padding: 50px; &#125; .son &#123; height: 100%; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1.0 获取元素 var box = document.querySelector(&#x27;.box&#x27;) // 2.0 直接获取元素的尺寸 offset 系列 计算元素的 border + padding + content console.log(box.offsetHeight + &#x27;： 元素的高度&#x27;) //300 height + padding + border console.log(box.offsetWidth + &#x27;： 元素的宽度&#x27;)//300 width + padding + border // offsetTop / offsetLeft 元素距离 body 的外边距 console.log(box.offsetTop + &#x27;： 元素的Top &#x27;) //默认情况下 是距离body的距离，top不会有默认的8像素 //默认情况下 是距离body的距离 如果不清除默认样式，没有对html、body设置内外边距值，浏览器会有默认的8像素，不会加自身的padding值 console.log(box.offsetLeft + &#x27;： 元素的Left&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、scroll系列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; padding: 30px; height: 3000px; &#125; .box &#123; width: 300px; height: 160px; background-color: red; padding: 40px; border: 19px solid #000; overflow: auto; &#125; .son &#123; width: 600px; height: 500px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1.0 获取元素 var box = document.querySelector(&#x27;.box&#x27;) // 2.0 直接获取元素的尺寸 scroll 系列 不包含border console.log(box.scrollHeight + &#x27;： 元素的高度&#x27;) console.log(box.scrollWidth + &#x27;： 元素的宽度&#x27;) // ！！！ 很重要的一个概念 scrollTop 计算的是内容滚动出去之后的那个距离 console.log(box.scrollTop + &#x27;： 元素的Top &#x27;) // console.log(box.clientLeft + &#x27;： 元素的Left &#x27;) // 3.0 给父盒子添加滚动事件 box.onscroll = function() &#123; console.log(box.scrollTop) console.log(box.scrollLeft) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 放大镜案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #small&#123; position: absolute; left: 30px; top: 30px; width: 400px; height: 400px; &#125; #small img&#123; width: 100%; height: 100%; &#125; #small .mark&#123; position: absolute; top: 0; left: 0; width: 100px; height: 100px; opacity: 0.4; background-color: #fff; display: none; &#125; #big&#123; position: absolute; left: 500px; top: 30px; width: 200px; height: 200px; border: 1px solid #000; overflow: hidden; display: none; &#125; #big img&#123; position: absolute; top: 0; left: 0; width: 800px; height: 800px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;small&quot;&gt; &lt;img src=&quot;../1.imgs/linght.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mark&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;big&quot;&gt; &lt;img src=&quot;../1.imgs/linght.jpg&quot; alt=&quot;&quot; id=&quot;pic&quot;&gt; &lt;/div&gt; &lt;script&gt; var small = document.querySelector(&#x27;#small&#x27;) var big = document.querySelector(&#x27;#big&#x27;) var mark = document.querySelector(&#x27;.mark&#x27;) var imgbox = document.querySelector(&#x27;#pic&#x27;) small.onmouseenter = function()&#123; mark.style.display = &quot;block&quot; big.style.display = &quot;block&quot; &#125; small.onmouseleave = function()&#123; mark.style.display = &quot;none&quot; big.style.display = &quot;none&quot; &#125; small.onmousemove = function(event)&#123; var e = event || window.event var l = e.clientX - small.offsetLeft - 50 var t = e.clientY - small.offsetTop - 50 if(l &lt;= 0) &#123; l = 0 &#125; if(l &gt;= 300)&#123; l = 300 &#125; if(t &lt;= 0) &#123; t = 0 &#125; if(t &gt;= 300)&#123; t = 300 &#125; mark.style.left = l + &quot;px&quot; mark.style.top = t + &quot;px&quot; imgbox.style.left = l* -2 + &quot;px&quot; imgbox.style.top = t* -2 + &quot;px&quot; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十一、轮播图常用的轮播图有两种，一种是滑动轮播图，这是用的最多的一种，还有一种是渐变轮播图，轮播图都是搭配封装好的动画库一起使用，效率会高很多 1、滑动轮播图（结构）1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;&gt; &lt;script src=&quot;./js/animate.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 主盒子 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 左右按钮 --&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;div class=&quot;arr-left&quot;&gt;&amp;lt;&lt;/div&gt; &lt;div class=&quot;arr-right&quot;&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 图 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-01.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-02.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-03.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-04.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-05.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-06.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 按钮 --&gt; &lt;ol&gt; &lt;li class=&quot;cur&quot;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、滑动轮播图（样式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* 清除默认样式 */* &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;img &#123; /* 让图片跟父盒子的大小一样 */ width: 100%; display: block;&#125;.container &#123; position: relative; width: 520px; /* 给高度为了让ol能定位到图片上面去 */ height: 346px; margin: 100px auto; overflow: hidden;&#125;.arrow &#123; /* 让左右两边的按钮定位在父盒子里面 */ position: absolute; top: 50%; left: 0; /* 让它们在y轴居中显示 */ transform: translateY(-50%); width: 100%; z-index: 999; display: none;&#125;.arr-left, .arr-right &#123; position: absolute; top: 50%; transform: translateY(-50%); color: #fff; font-size: 30px; /* 如果觉得夹角不好看，那就改变字体样式 */ font-family: simsun; width: 40px; height: 60px; text-align: center; line-height: 60px; background-color: rgba(0, 0, 0, 0.5); cursor: pointer;&#125;.arr-left &#123; left: 10px;&#125;.arr-right &#123; right: 10px;&#125;ul &#123; width: 5000px; /* 为了让看的出图片在走，也加个定位然后去修改left的值 */ position: relative; left: 0; /* transition: left 0.4s linear; */&#125;ul li &#123; /* 让图片一字排开，然后再用溢出隐藏 */ float: left; width: 520px;&#125;ol &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);&#125;ol li &#123; float: left; margin: 0 5px; font-size: 12px; width: 15px; height: 15px; border-radius: 50%; text-align: center; line-height: 15px; cursor: pointer; background-color: rgba(255, 255, 255, 0.5);&#125;ol li.cur &#123; background-color: #fff;&#125; 3、滑动轮播图（行为）（动画库另外找）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106window.onload = function()&#123;// 1.获取 按钮、图片父盒子、父盒子、左右按钮、图片宽度var ollis = document.querySelectorAll(&#x27;ol li&#x27;)var ulbox = document.querySelector(&#x27;ul&#x27;)var container = document.querySelector(&#x27;.container&#x27;)var arrow = document.querySelector(&#x27;.arrow&#x27;)var rightbox = document.querySelector(&#x27;.arr-right&#x27;)var leftbox = document.querySelector(&#x27;.arr-left&#x27;)var distTime = 10;// 一张图片的距离var imgwidth = ulbox.children[0].offsetWidth// 修改了结构，这是为了让能看见的图片显示的是第一张ulbox.style.left = -imgwidth + &#x27;px&#x27;//在前面加一张图片var firimg = ulbox.children[0].cloneNode(true)//在最后面加一张图片var lastimg = ulbox.children[ulbox.children.length - 1].cloneNode(true)ulbox.appendChild(firimg)ulbox.insertBefore(lastimg,ulbox.children[0])// 2.操作ol中的小圆点样式ollis.forEach(function(el,index) &#123; el.onclick = function() &#123; ollis.forEach(function(item) &#123; item.removeAttribute(&quot;class&quot;) &#125;) el.className = &quot;cur&quot; ani(ulbox, &#x27;left&#x27;, -(index + 1) *imgwidth) count = index + 1 &#125;&#125;)// 3.显示左右按钮container.onmouseover = function()&#123; arrow.style.display = &quot;block&quot; clearInterval(timer)&#125;container.onmouseout = function()&#123; arrow.style.display = &quot;none&quot; clearInterval(timer) timer = setInterval(function()&#123; rightbox.onclick() &#125;,2000)&#125;var count = 1var flag = true// 4.点击左右按钮切换rightbox.onclick = function ()&#123; if(flag)&#123; flag = false count++ if(count &gt; 6) &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth, function()&#123; count = 1 ulbox.style.left = -count * imgwidth + &quot;px&quot; it(count - 1) flag = true &#125;) &#125;else &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth,function() &#123; flag = true &#125;) it(count - 1) &#125; &#125;&#125;leftbox.onclick = function ()&#123; if(flag)&#123; count-- if(count &lt;= 0) &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth, function()&#123; count = 6 ulbox.style.left = -count * imgwidth + &quot;px&quot; it(count - 1) flag = true &#125;) &#125;else &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth,function()&#123; flag = true &#125;) it(count - 1) &#125; &#125;&#125;//封装一个排他function it(n)&#123; ollis.forEach(function(item) &#123; item.removeAttribute(&quot;class&quot;) &#125;) ollis[n].className = &quot;cur&quot;&#125;// 5.自动轮播var timer = setInterval(function()&#123; rightbox.onclick()&#125;,2000)&#125; 4、渐变轮播图（结构）1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/swiper.css&quot;&gt; &lt;script src=&quot;./js/style.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 主盒子 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 左右按钮 --&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;div class=&quot;arr-left&quot;&gt;&amp;lt;&lt;/div&gt; &lt;div class=&quot;arr-right&quot;&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 图 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-01.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-02.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-03.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-04.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-05.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-06.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 按钮 --&gt; &lt;ol&gt; &lt;li class=&quot;cur&quot;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、渐变轮播图（样式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 清除默认样式 */* &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;img &#123; /* 让图片跟父盒子的大小一样 */ width: 100%; display: block;&#125;.container &#123; position: relative; width: 520px; /* 给高度为了让ol能定位到图片上面去 */ height: 346px; margin: 100px auto; /* overflow: hidden; */&#125;.arrow &#123; /* 让左右两边的按钮定位在父盒子里面 */ position: absolute; top: 50%; left: 0; /* 让它们在y轴居中显示 */ transform: translateY(-50%); width: 100%; z-index: 999; display: none;&#125;.arr-left, .arr-right &#123; position: absolute; top: 50%; transform: translateY(-50%); color: #fff; font-size: 30px; /* 如果觉得夹角不好看，那就改变字体样式 */ font-family: simsun; width: 40px; height: 60px; text-align: center; line-height: 60px; background-color: rgba(0, 0, 0, 0.5); cursor: pointer;&#125;.arr-left &#123; left: 10px;&#125;.arr-right &#123; right: 10px;&#125;ul &#123; position: relative;&#125;ul li &#123; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity .8s ease-in-out;&#125;ul li:first-of-type&#123; opacity: 1; z-index: 1;&#125;ol &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); z-index: 88;&#125;ol li &#123; float: left; margin: 0 5px; font-size: 12px; width: 15px; height: 15px; border-radius: 50%; text-align: center; line-height: 15px; cursor: pointer; background-color: rgba(255, 255, 255, 0.5);&#125;ol li.cur &#123; background-color: #fff;&#125; 6、渐变轮播图（行为）（不用加动画库） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980window.addEventListener(&#x27;load&#x27;, function() &#123; // 获取 按钮、图片父盒子、父盒子、左右按钮、图片宽度 var ollis = document.querySelectorAll(&#x27;ol &gt; li&#x27;) var ulbox = document.querySelector(&#x27;ul&#x27;) var container = document.querySelector(&#x27;.container&#x27;) var arrow = document.querySelector(&#x27;.arrow&#x27;) var rightbox = document.querySelector(&#x27;.arr-right&#x27;) var leftbox = document.querySelector(&#x27;.arr-left&#x27;) // 操作ol中的小圆点样式 ollis.forEach(function(el,index) &#123; el.onclick = function() &#123; fn(index) count = index &#125; &#125;) // 浅封装一下排他 function fn(n) &#123; // 排他 ollis.forEach(function(item, i) &#123; item.removeAttribute(&#x27;class&#x27;) // 以此次遍历同步操作ulBox ulbox.children[i].style.opacity = 0 &#125;) ollis[n].className = &#x27;cur&#x27; ulbox.children[n].style.opacity = 1 &#125; // 3.0 鼠标经过大盒子，显示左右按钮 container.addEventListener(&#x27;mouseover&#x27;, function() &#123; arrow.style.display = &#x27;block&#x27; clearInterval(timer) &#125;) container.addEventListener(&#x27;mouseout&#x27;, function() &#123; arrow.style.display = &#x27;none&#x27; clearInterval(timer) timer = setInterval(function() &#123; rightbox.click() &#125;, 2000) &#125;) // 4.0 左右按钮点击事件 var count = 0 var flag = true rightbox.addEventListener(&#x27;click&#x27;, function() &#123; if(flag) &#123; flag = false count++ if(count &gt; ollis.length - 1) count = 0 fn(count) &#125; &#125;) leftbox.addEventListener(&#x27;click&#x27;, function() &#123; if(flag) &#123; flag = false count-- if(count &lt; 0) count = ollis.length - 1 fn(count) &#125; &#125;) // 在监听谁的渐变？ ul &gt; li 以前有一个监听动画结束的事件 webkitAnimationEnd webkitTransitionEnd for(var i = 0; i &lt; ulbox.children.length;i++)&#123; ulbox.children[i].addEventListener(&quot;webkitTransitionEnd&quot;,function()&#123; flag = true &#125;) &#125; // 5.0 自动轮播 var timer = setInterval(function() &#123; // 其实就是右边按钮的点击 rightbox.click() &#125;, 2000)&#125;)","categories":[],"tags":[]}],"categories":[],"tags":[]}