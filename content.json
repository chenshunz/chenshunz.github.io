{"meta":{"title":"Onece || Aaras","subtitle":null,"description":null,"author":"极度简单.","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"less","date":"2022-04-19T01:24:16.426Z","updated":"2022-04-19T01:22:51.369Z","comments":true,"path":"2022/04/19/less/","link":"","permalink":"http://example.com/2022/04/19/less/","excerpt":"","text":"title:less笔记less常用的方法、ps：在less中分号是很重要的。 一、变量多次重复相同的值，通常在您的样式表中可看到。不用多次使用相同的值，可以使用变量。它使代码的维护更容易，并且可以从单个位置控制这些值。 变量作为样式的值使用 123456@w:100px;#div &#123; width: @w; height: @w; background-color: aqua;&#125; 变量作为变量的名字--@{变量名} 1234567@bg : background;#bg&#123; width: 300px; height: 300px; @&#123;bg&#125;: red; margin: auto;&#125; 变量作为选择器使用--@{选择器} 123456@w:#div;@&#123;w&#125; &#123; width: 300px; height: 300px; background-color: red;&#125; 变量作为url地址 123456789101112131415161718@img1:&#x27;https://www.baidu.com/img/flexible/logo/pc/result@2.png&#x27;;@img2:url(&#x27;https://www.baidu.com/img/flexible/logo/pc/result@2.png&#x27;);@img3:@img2;#outer &#123; width: 300px; height: 300px; background-color: aqua; margin: auto; position: absolute; left: 0; top: 0; bottom: 0; right: 0; // background:url(@img1) 0 0 no-repeat; // background: @img2 0 0 no-repeat; background: @img3 0 0 no-repeat;&#125; 变量的计算 12345678910111213@v:0;@z:@v + 2;#outer &#123; width: 300px; height: 300px; background-color: aqua; margin: auto; position: absolute; left: @v; top: @v; bottom: @v; right: @z;&#125; 二、嵌套​ 在使用标准CSS时，要为多层嵌套的元素定义样式，要么使用后代选择器从外到内的嵌套定义，要么给这个元素加上类名或 id 来定义。这样的写法虽然很好理解，但维护起来很不方便，因为无法清晰了解到样式之间的关系。 在Less中，嵌套规则使这个问题迎刃而解。嵌套规则允许在一个选择器中嵌套另一个选择器，这更容易设计出精简的代码，并且样式之间的关系一目了然。 123456789101112131415body&#123; background-color: red; .header&#123; height: 100px; background-color: yellow; &#125; .con&#123; margin: 0 auto; border: 1px solid green; &#125; .footer&#123; width: 1200px; box-shadow: 0px 0px 0px 0px #ccc; &#125; &#125; 使用&amp;：代表前边的所有父级元素，常用在伪元素 伪类 css结构类等需求上 内层选择器前面的 &amp; 符号就表示对父选择器的引用。在一个内层选择器的前面，如果没有 &amp; 符号，则它被解析为父选择器的后代；如果有 &amp; 符号，它就被解析为父元素。 123456789101112ul&#123; li&#123; line-height: 40px; &amp;:nth-child(1)&#123; line-height: 80px; &#125; &#125; li:nth-child(1)&#123; line-height: 80px; &#125;&#125; 三、less混合混合是一种将一组属性从一个规则集包含或混入到另一个规则集的方法。 简单一点来说，其实混合就有点类似编程语言中的函数，通过这种方式，可以在代码中实现复用。 12345678.s1 &#123; font-size: 14px; color: #ccc;&#125;.s2 &#123; .s1;//注意没有加（），如果加了相当于是函数调用 padding: 10px;&#125; 在声明混合的时候，可以在小括号中声明形参。形参由@+变量名定义。调用的时候可以传入实参 如果很多的位置都需要使用某一个Mixins，而且参数还不一样的话，那么就可以使用参数的Mixins 12345678.s1(@f,@c)&#123; font-size: @f; color: @c; &#125;.s2&#123; .s1(14px,red);//这里是实参 padding: 10px; &#125; 可以直接在混合中定义形参的时候，给形参设置默认值，比如（@color:red），当使用混合的时候，如果有实参传递，则使用实参的值，否则使用形参的默认值 123456789.s1(@f:10px,@c:red)&#123; font-size: @f; color: @c; &#125; .s2&#123; .s1();//这里的小括号内是实参，如果没有实参的话，就会用变量默认值 padding: 10px;&#125; Mixins命名空间 Less 中也有命名空间的概念，命名空间用于在通用名称下对 Mixins 进行分组，使用命名空间可以避免名称冲突，并从外部封装 Mixins 组。例如可以将类选择器或者ID选择器作为一个命名空间，然后将 Mixins 放在命名空间中，这样可以避免与引入的其他文件造成冲突 套一层外套。 12345678910111213.name_space&#123; .s1()&#123; font-size: 12px; &#125; &#125; .s2&#123; //五种 // .name_space &gt; .s1(); // 引用 以下哪种方式都可以 // .name_space.s1; // .name_space.s1(); // .name_space .s1; .name_space .s1(); &#125; !important关键字 !important 关键字用于覆盖特定属性。如果我们在 Mixins 引用后面加上 !important 关键字，则会将 Mixins 中的所有属性标记为 !important 。 1234567.mixin()&#123; color: red;&#125;h1&#123; color: #ccc; .mixin() !important;&#125; 匹配模式 在Less中尝试利用模式匹配替if&#x2F;else，其执行原理类似switch&#x2F;case。 因为一个混合可能有多种形式，所以Less提供了一种机制，允许根据参数的值来改变 mixin的行为。 其中当参数是@_开头的，是调用此混合必选的。 1234567891011121314151617//模式匹配中，公有的样式混合 需要书写@_做为参数.main(@_) &#123; width: 100px; height: 100px;&#125;.main(color1) &#123; background-color: pink;&#125;.main(color2) &#123; background-color: yellow;&#125;.outer &#123; .main(color1)&#125; 重载 相同的混合，不同的行为，可以根据调用的时候传入的实参个数选择匹配的混合内容 12345678910111213.main(@w) &#123; width: @w;&#125;.main(@w, @h) &#123; width: @w; height: @h;&#125;.outer &#123; //重载：根据参数个数不同，来匹配不同的混合 .main(100px, 100px)&#125; 根据判断条件选中Mixin的行为 类似于JavaScript的if&#x2F;else，使用when语法 Guards 允许我们使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;,关键字true（只匹配关键字true，非true不会匹配）， 支持逻辑and 和逗号（或者）以及not () 同时我们可以使用“，”分割多个Guards，其表示只要其中任意一个满足就为true 就是判断条件 12345678910111213.main(@a) when(@a&gt;30) &#123;//如果传入的实参大于30就走这个 width: 100px; height: 100px;&#125;.main(@a) when(@a&lt;=30) &#123;//如果传入的实参小于等于30就走这个 width: 200px; height: 200px;&#125;.outer &#123; .main(30)&#125; 也可以加and关键字来进行连接判断 1234567891011121314151617.main(@w) when(@w&gt;1000),(@w&lt;200) &#123; width:~&quot;@&#123;w&#125;px&quot;; height: 100px;&#125;.main(@w) when(@w&lt;=1000) and (@w&gt;=200) &#123; width:~&quot;@&#123;w&#125;px&quot;; height: 50px;&#125;.main(@b) when(not(@b&lt;=30))&#123; background: red;&#125;.outer &#123; .main(3000)&#125;","categories":[],"tags":[]},{"title":"JQuery笔记","slug":"jQuery","date":"2022-04-15T10:54:36.622Z","updated":"2022-04-19T01:21:59.277Z","comments":true,"path":"2022/04/15/jQuery/","link":"","permalink":"http://example.com/2022/04/15/jQuery/","excerpt":"","text":"一、JQuery​ 干什么: 一个优秀的js函数库，官网：http://jquery.com/ ​ jQuery简介： ​ * 是在2006年,美国人约翰创建的,jquery是一个js的文件 \\* 目的:因为以后工作中,会有一些老项目,就是用jquery来编写的,jquery可以认 \\* 为是前端人员必会的,学习它也是为了让我们更好的理解js,可以把经历放在项目 ​ * 的业务逻辑上,而不用过多的操心兼容性问题,jq可以解决95%兼容性问题 ​ * Why? * HTML元素选取(选择器) ​ * HTML元素操作 ​ * CSS操作 ​ * HTML事件处理 ​ * 链式调用 （重点） ​ * 读写合一 （重点） ​ * How? ​ * 1.引入jQuery库 ​ * 2.使用jQuery: jQuery核心函数 jQuery核心对象 ​ * 3.区别2种js库文件: 开发版(源码版) 生产版(压缩版) ​ * 4.区别2种引用js库的方式: 服务器本地库 ​ * CDN远程库 https://www.bootcdn.cn/ ​ jQuery的优点： ​ 使用简单方便 – 宗旨：Write Less, Do More。写得少，做得多。吃得少干得多。 ​ jQuery能做的js能做，js能做的jQuery也能做， ​ 但是jquery简单、易懂、兼容性好（解决了几乎所有的兼容性问题）。 ​ 链式编程 ​ 隐式迭代(隐式遍历):可以不用循环遍历对dom操作 ​ 读写合一 跟原生比： 原生版 需要将所有的dom元素以及相关的资源（img、css、js、font、音频、视频…）全部加载完毕之后才来执行的事件回调函数 window.onload &#x3D; function () {} jQuery版 只需要将所有的dom元素加载完毕之后就会执行这个函数 $(function () {}） 123456789101112131415// $一定是一个函数// $() fun()// $(function()&#123;&#125;) //fun(function()&#123;&#125;) function()&#123;&#125;是作为$这个函数的实参，也是回调函数// $(&#x27;#btn2&#x27;) 返回结果：元素对象// $(&#x27;#btn2&#x27;).click 这个元素对象中一定有一个属性叫click// $(&#x27;#btn2&#x27;).click() 证明click属性的值一定是一个函数// $(&#x27;#btn2&#x27;).click(function()&#123;&#125;) function()&#123;&#125;是作为函数的实参// 立即执行函数// (function () &#123;&#125;)(); 二、jQuery的两把利器1、jQuery核心函数 * 简称: jQuery函数($&#x2F;jQuery) * jQuery库向外直接暴露的就是$&#x2F;jQuery 暴露数据如果是直接暴露的，那么使用的时候直接使用即可。 * 引入jQuery库后, 直接使用$即可 * 当函数用: $(xxx) * 当对象用: $.xxx() 2、jQuery核心对象 * 简称: jQuery对象 * 得到jQuery对象: 执行jQuery函数返回的就是jQuery对象 * 使用jQuery对象: $(‘选择器对象’).css() 作为一般函数调用：$(param)1.参数为函数：当DOM加载完成后，执行此回调函数，window.onload和$(function(){}) 两个方式对比，是jq执行速度快 2.参数为选择器字符串：查找所有匹配的标签，并将他们封装成jQuery对象。$(“选择器”) 3.参数为DOM对象：将DOM对象封装成jQuery对象。$(dom对象)（括号内不用加引号） 4.参数为html标签字符串（用的少）：创建标签对象并封装成jQuery对象 5.js和jq可以共存在一个页面上，但是不能混用在一行代码上 6.伪数组，其实是对象！！jq对象一般都是伪数组 1234567//jq中没有自己的this指向，还是使用的js中的this指向console.log(this); //如果返回来的是标签本身，那么这个对象就是dom对象如何将dom对象转换成响应的jq对象console.log($(this)); //伪数组console.log(typeof $(this)); //object 作为对象使用：$.xxx()1.JQuery对象是一个包含所有匹配的任意多个dom元素的伪数组对象 2.基本行为： ​ size()&#x2F;length: 包含DOM元素个数 ​ [index]&#x2F;get(index) ：得到对应位置的DOM元素 ​ each():遍历包含的所有DOM元素 ps：each既可以遍历数组、对象、还可以遍历DOM元素对象 1.如果是数组或普通对象：$.each(对象名，function（下标，值）{})（下标和键名不能省略） 1234567891011121314151617181920212223var arr2 = [ [1,2,3], [4,5,6], [7,8,9]]$.each(arr2,function(index,item)&#123; $.each(item,function(i,v)&#123; console.log(v); &#125;)&#125;var obj = &#123; name:&#x27;刚哥&#x27;, age:45&#125;$.each(obj,function(key,value)&#123; //key表示的对象的键名 // console.log(key); //value表示的对象的键值 console.log(value);&#125;) 2.如果是DOM对象：$(“选择器对象”).each(function(下标,值){})（下标不能省略） 123456789$(&#x27;button&#x27;).each(function(index,value)&#123; //下标 // console.log(index); //元素对象 // console.log(value); //jq对象 // console.log($(value)); console.log($(value).html());&#125;) 三、常用属性1、操作任意属性 attr()：读写合一 如果传递的是一个参数：读，相当于getAttribute 如果传递的是二个参数：写，相当于setAttribute ps：attr设置的属性值如果之前存在的话，则默认是覆盖，一般设置普通属性，也可以设置自定义属性（$(‘button’).attr(‘abc’,100)） removeAttr()：移除属性 prop()：一般操作属性如果是布尔值之类的属性，则使用prop方法 复选框、单选按钮、下拉列表、readonly、disabled 一般主要针对于的是选中类的属性的设置 2、操作class属性 addClass()： 添加类名 removeClass()：移除类名 3、操作HTML代码&#x2F;文本&#x2F;值 html()：读写合一，括号为空就是读，写的话在括号内加，记得加引号 val()（获取输入框的值，表单用） 4、在jQuery对象中的元素对象数组中过滤出一部分元素来 \\1. first()：第一个元素 \\2. last()：最后一个元素 \\3. eq(index|-index) ：匹配元素的集合为指定的索引的哪一个元素。 \\4. filter(selector)：过滤出需要的元素 \\5. not(selector)：找到不为xxxx的元素 5、查找子、父、兄弟标签 children(): 获得匹配元素集合中元素的子元素，然后选择器选择性筛选 find()：通过一个选择器，jQuery对象，得到当前匹配的元素集合中每个元素的后代，不区分层级 parent()&#x2F;parents():找上一级父标签&#x2F;找所有父标签 prevAll()&#x2F;prev(): ：查找所有符合选择器或符合参数前面的标签&#x2F;prev方法就不要添加参数了，因为加了这个参数要严格了，有可能布局发送了变化，就影响了 “+” 是前面标签的下一个兄弟标签 console.log($(‘li#cc + ‘)); “~” 是前面标签下所有兄弟标签 console.log($(‘li#cc ~ li’)); siblings()：是获取所有除自己以外的兄弟标签，不分前后 toggleClass()：开关样式，你有我删，你没有我加 append():&#x2F;appendTo():内部默认追加在后 prepend()&#x2F;prependTo() ： 内部默认追加在前 Before()&#x2F;insertBefore(): 外部默认追加在前 after()&#x2F;insertAfter(): 外部默认追加在后 replaceWith()&#x2F;replaceAll():新all旧，旧with新 remove():不添加参数移除所有 empty();是将这个父元素中的所有的普通文本以及子元素全部删除掉 四、元素的尺寸1234567891. 内容尺寸 content-box height(): height width(): width2. 内部尺寸 content-box + padding-box innerHeight(): height+padding innerWidth(): width+padding3. 外部尺寸 content-box + padding-box + border-box outerHeight(false/true): height+padding+border 如果是true, 加上margin outerWidth(false/true): width+padding+border 如果是true, 加上margin","categories":[],"tags":[]},{"title":"Js高级","slug":"js高级","date":"2022-04-10T16:01:09.574Z","updated":"2022-04-19T01:22:23.928Z","comments":true,"path":"2022/04/11/js高级/","link":"","permalink":"http://example.com/2022/04/11/js%E9%AB%98%E7%BA%A7/","excerpt":"","text":"一、选择排序最主要的就是内层循环的时候，是由i+1开始 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [12, 44, 56, 21, 42, 32] for(i = 0;i &lt; arr.length - 1; i++)&#123; for(j = i + 1; j &lt; arr.length;j++)&#123; if(arr[i] &gt; arr[j])&#123; var temp = arr[i] arr[i] = arr[j] arr[j] = temp &#125; &#125; &#125; console.log(arr); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、快速排序采用的递归的方法，需要注意的是，每一次都会把左边或右边的新数组进行重新比较然后再排序，然后要设计好出口，不然会一直循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [83, 66, 74, 32, 55, 12, 23, 45] // 递归函数的出口 function quickSort(array) &#123; if(array.length &lt;= 1)&#123; return array &#125; // 1.先找基准值（数组长度折半），下标 var index = Math.ceil(array.length / 2) console.log(index); // 2.删除数组中的基准值 var value = array.splice(index,1)[0] console.log(value); var left = [] var right = [] console.log(array); // 3.遍历现在的array数组 for(var i = 0;i &lt; array.length; i++)&#123; if(array[i] &lt; value)&#123; //放进左边数组 left.push(array[i]) &#125;else&#123; //放进右边的数组 right.push(array[i]) &#125; &#125; //4.合并成一个新的结构 // 小 + 中 + 大 //在函数的内部调用自身函数的意义就在于函数内部的代码循环利用 console.log(left); console.log(right); return quickSort(left).concat(value,quickSort(right)) &#125; //调用函数 console.log(quickSort(arr)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三、浅拷贝和深拷贝拷贝：发生在数组和对象中 其实不管是深拷贝还是浅拷贝，只要赋值的元素值是引用数据类型，则修改一方是会影响另一方 浅拷贝：地址的传递，只要是同一个地址值，无论修改了那一方，另一方都会受影响，你改我也改 1、浅拷贝的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1.对象和数组两个类型放在一个函数中做浅拷贝 // 2.考虑到原变量的数据类型是不是需要做浅拷贝的对象和数组 // 如果是对象/数组 // 如果是对象，创建一个同类型的变量&#123;&#125; // 如果是数组，创建一个同类型的变量[] // 3.再将原数组/原对象，里面的数据依此拷贝到新变量里面 // 定义数据 var arr = [1,2,3,4,[10,20,30]] var obj1 = &#123;a:100&#125; // 定义函数 function shallowCopy(obj) &#123; //先考虑类型 // typeof instanceof检测数据的方法 if(typeof obj != &quot;object&quot;)&#123; return &#125; //判断obj传入的到底是数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125; //将原变量的值依此拷贝到新变量里面（遍历拷贝） for (var key in obj) &#123; //⑥ 在遍历的时候需要考虑到原变量中是否有数据,如果没有数据就不需要拷贝了 //对象原型身上一个方法：用来检测这个数组/对象中是否有下标/键名 //如果有则返回true；否则返回false //hasOwnProperty if(obj.hasOwnProperty(key))&#123; newObj[key] = obj[key] // 地址 &#125; &#125; return newObj &#125; //③ 调用函数 var newArr = shallowCopy(arr); newArr[4][0] = 100; console.log(newArr); console.log(arr); /* newArr[0] = 10; console.log(arr); console.log(newArr); */ /* var obj2 = shallowCopy(obj1); obj2.a = 200; console.log(obj1); console.log(obj2); */ // console.log(Object.prototype); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、深拷贝：修改其中数组的下标值，看另一个数组对应下标的值是否会变化 1、深拷贝–slice和concat方法12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--使用slice和concat slice：截取 slice形成的是一个新数组，不会影响原数组的结构 concat:合并 --&gt; &lt;script&gt; // var arr = [1,2,3,4,5]; // var newArr = arr.slice(0); // newArr[0] = 100; // console.log(newArr); // console.log(arr); // var arr = [1,2,3,4,5]; // var newArr = arr.concat(); // arr[0] = 100; // console.log(newArr); // console.log(arr); //其实不管是深拷贝还是浅拷贝，只要赋值的元素值是引用数据类型，则修改一方是会影响另一方 var arr = [ &#123; str: &#x27;hello&#x27; &#125;, [&#x27;old&#x27;] ] var newArr = arr.slice(0); arr[0].str = &quot;world&quot;; newArr[1][0] = &quot;new&quot;; console.log(arr); console.log(newArr); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、深拷贝的JSON方法1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [&#x27;old&#x27;,1,true,[&#x27;old1&#x27;,&#x27;old2&#x27;],&#123;old:1&#125;] //将数组对象转换成相应的字符串 var str = JSON.stringify(arr) // //按照这样的字符串转换成相应的对象 var newArr = JSON.parse(str)// // 注意：只有遍历赋值的时候是基本数据类型你改了我不改，引用数据类型你改了我也改 // 但是如果通过JSON字符串的方法再次转换成对象的话，则即使是引用数据类型也不会是你改我也改 newArr[0] = &quot;new&quot; newArr[3][0] = &quot;old3&quot; console.log(arr); console.log(newArr); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、深拷贝封装好的通用方法123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var obj = [&#123;&#x27;a&#x27;:&#123;&#x27;a1&#x27;:[&#x27;a11&#x27;,&#x27;a12&#x27;],&#x27;a2&#x27;:1&#125;,&#x27;b&#x27;:2&#125;,[&#x27;c&#x27;,&#123;&#x27;d&#x27;:4,&#x27;e&#x27;:5&#125;]] //1.准备一个函数 function DeepCopy(data)&#123; if(typeof data != &#x27;object&#x27;) return //创建一个变量，根据类型来进行创建 var newObj = data instanceof Array?[] : &#123;&#125; //遍历原obj数组 for(var key in data)&#123; //递归复制 if(data.hasOwnProperty(key))&#123; newObj[key] = typeof data[key] == &quot;object&quot; ? DeepCopy(data[key]) : data[key] &#125; &#125; return newObj &#125; var res = DeepCopy(obj) console.log(res); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、节流设置一个开关，如果上一次事件还没执行完，下一次就执行不了。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 节流是设置一个开关，先开进去之后再关，执行完之后再开 --&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; var ipt = document.querySelector(&#x27;input&#x27;) function handle()&#123; console.log(&quot;向服务器请求数据&quot;); &#125; var flag = true function debance()&#123; if(flag)&#123; flag = false setTimeout(function()&#123; handle() flag = true; &#125;,2000) &#125; &#125; ipt.addEventListener(&#x27;keyup&#x27;,debance) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、防抖每次请求都先清除上一次的定时器 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 防抖是每次请求先清除上一次的定时器 --&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; var ipt = document.querySelector(&#x27;input&#x27;) ipt.addEventListener(&quot;keyup&quot;,debance(handler.bind(ipt,10))) function handler()&#123; console.log(&quot;向服务器请求数据&quot;); console.log(this); &#125; function debance(a)&#123; var timer; return function()&#123; clearTimeout(timer) timer = setTimeout(function()&#123; a() &#125;,2000) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、闭包（就说是一种引用关系）闭包帮助我们解决在全局中也想要函数中的局部变量 ​ * 形成闭包函数的四个先决条件【必须都满足才可以】 ​ * 1. 外部函数必须要先调用 ​ * 2. 外部函数里面有内部函数的嵌套 ​ * 3. 内部函数需要作为外部函数的返回值 ​ * 4. 内部函数需要引用外部函数的变量（局部&#x2F;形参） 12345678910111213141516171819202122232425 function fun()&#123; var a = 1; var b = 2; function f1()&#123; a++; return a; &#125; return f1; &#125; var result = fun(); console.log(result);// result = null; //释放闭包这也是一个闭包函数/* function fun(a)&#123; return function()&#123; setTimeout(function()&#123; console.log(a); &#125;,3000) &#125; &#125; fun(); */ 七、修改this的指向（call，apply，bind）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- call和apply的区别：传递函数的实参形式上不同 函数对象.call(this指向,实参1,实参2...,实参n) 函数对象.apply(this指向,[实参1,实参2...,实参n]) call和bind的区别：是否会立即执行的问题 call和apply都是先修改this指向，然后就立即执行函数 bind先修改指向，返回的是当前函数体，可以自行选择调用位置 相同点：都可以修改this指向 --&gt; &lt;script&gt; /* var obj = &#123;&#125;; function f(x, y) &#123; console.log(x, y); // 1 2 console.log(this); //obj对象 &#125; // f.apply(obj, [1, 2]); f.call(obj, 1, 2); */ //看bind的使用 /* var obj = &#123;&#125;; function f() &#123; console.log(&quot;看我怎么调用&quot;); console.log(this); &#125; //修改this指向 var f1 = f.bind(obj); f1(); */ //有参数 /* function fn(a, b, c) &#123; console.log(a); console.log(b); console.log(c); &#125; var f = fn.bind(null,10); f(20,30); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、原型链有一张图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 初级原型链涉及的对象： 1.Student函数对象 2.Student函数的实例对象 3.Object函数对象 --&gt; &lt;script&gt; function Student(name)&#123; this.name = name; &#125; /* Student.prototype.study = function()&#123; console.log(&#x27;学习1&#x27;); &#125; */ Object.prototype.study = function()&#123; console.log(&#x27;学习2&#x27;); &#125; var s1 = new Student(&#x27;老王&#x27;); s1.study(); //关系链条： //1.函数即使不发生new，函数对象本身中也会存在prototype属性 //2.先有函数对象.prototype指向的那个对象中存在的数据，然后s1.__proto__也指向了那个对象 //如果反问咱们，想要给实例对象身上添加方法，给函数的显示原型对象身上添加 console.log(s1.__proto__ = Student.prototype); console.log(Student.prototype.__proto__ = Object.prototype); console.log(Object.prototype.__proto__); //null // console.dir(Student); // console.dir(Function.prototype); // console.log(Object.prototype.__proto__); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 九、方法的重载和重写重载：同一个方法会根据参数的不同来执行不同的业务逻辑，发生在一个类身上 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法重载：同一个方法会根据参数的不同来执行不同的业务逻辑 发生在一个类身上 --&gt; &lt;script&gt; function Student(name)&#123; this.name = name; &#125; Student.prototype.eat = function(address,who)&#123; console.log(&#x27;和&#x27;+who + &#x27;在&#x27;+address + &#x27;吃饭&#x27;); &#125; var s1 = new Student(); //在实例对象调用同一个方法的时候，通过传递不同的参数，达到不同的效果 s1.eat(&#x27;大街上&#x27;,&#x27;小姐姐&#x27;,); s1.eat(&#x27;咖啡馆&#x27;,&#x27;小哥哥&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 重写：和父类同名方法功能不同，被称作方法重写，发生在两个类身上 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法重写：和父类同名方法功能不同，被称作方法重写 发生在两个类身上 --&gt; &lt;script&gt; function Person()&#123; this.eat = function()&#123; console.log(&#x27;吃饭&#x27;); &#125; &#125; function Student(name)&#123; this.name = name; Person.call(this) this.eat = function(address)&#123; console.log(this.name + &#x27;去&#x27;+address+&#x27;吃饭&#x27;); &#125; &#125; function Doctor(name)&#123; this.name = name; Person.call(this); this.eat = function(who)&#123; console.log(this.name + &#x27;和&#x27;+who+&#x27;吃饭&#x27;); &#125; &#125; var s1 = new Student(&#x27;王云飞&#x27;); s1.eat(&#x27;食堂&#x27;); var d1 = new Doctor(&#x27;老王&#x27;); d1.eat(&#x27;媳妇&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"BOM笔记","slug":"BOM笔记","date":"2022-04-10T15:16:51.995Z","updated":"2022-04-19T01:21:36.023Z","comments":true,"path":"2022/04/10/BOM笔记/","link":"","permalink":"http://example.com/2022/04/10/BOM%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、BOMBOM是 browser object model 的缩写，简称浏览器对象模型 ，提供了独立于内容而与浏览器窗口进行交互的对象； window对象，是JS的最顶层对象，其他的BOM对象都是window对象的属性 1、locationLocation 对象包含有关当前 URL 的信息。Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 拓展：URL 统一资源定位系统（uniform resource locator）的组成（了解） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* location对象 我们浏览器上的地址栏输入框 【注】它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能location对象中的属性: url 统一资源定位符(相当于快递包上的一个地址) 英文：protocol(协议):hostname(主机名)：port(端口号)/pathname(路径)?查询字符串(search)#锚点(hash) http://www.baidu.com:8080/code/xxx.html?username=xxx&amp;age=18#1 中文描述：协议://IP(域名):端口号/路径/?查询字符串#锚点 location.protocol file:本地磁盘文件访问 http: https:(证书认证协议) location.hostname 主机名 IP（在全球范围内找到你当前网络的地址） 域名 就是IP的别称 location.port 端口号（默认隐藏的） 【注】 是当前电脑中使用网络的软件，随机给他分配的一个编号 0~65535 hostname:port 可以直接定位到当前使用网络的程序 小细节： 浏览器 8080 http： 80 https 443 location.pathname 路径 location.search 查询字符串 格式有要求的： ?username=xxx&amp;age=18 location.hash 锚点 */ // alert(location.protocol); // alert(location.hostname); // alert(location.pathname); // alert(location)输出location对象 // alert(location.href)输出整个url /* location方法： location.assign(url) [注]在当前窗口跳转带这个url location.replace(url) [注]在当前窗口替换成新的url，不会产生历史记录 location.reload() [注]刷新当前窗口 location.reload(true) 不经过浏览器缓存强制从服务器重载 */ &lt;/script&gt; &lt;button onclick=&quot;location.assign(&#x27;https://www.baidu.com&#x27;)&quot;&gt;assign&lt;/button&gt; &lt;button onclick=&quot;location.replace(&#x27;https://www.baidu.com&#x27;)&quot;&gt;replace&lt;/button&gt; &lt;button onclick=&quot;location.reload(true)&quot;&gt;replace&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; location值得注意的属性是:12location.seach 获取到查询参数 location.hash 获取到哈希值location.href = &#x27;&#x27; 跳转页面 location.reload() 刷新页面 2、history（了解）浏览器的前进与后退12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; //history.back() 后退 history.forword() 前进 history.go() 0:刷新 1：前进 -1：后退 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、navigator （了解） 管着浏览器的版本内核信息。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(navigator ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、screen（了解）包含有关客户端显示屏幕的信息1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(screen); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、正则表达式（要验证什么就去百度查）推荐网址：https://blog.csdn.net/weixin_30378623/article/details/97499364?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164960505016780261965242%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164960505016780261965242&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-97499364.142^v7^pc_search_result_cache,157^v4^control&amp;utm_term=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%A4%A7%E5%85%A8&amp;spm=1018.2226.3001.4187 1、创建正则表达式的方式12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1、使用构造函数创建正则 var demo = new RegExp(/abc/) // 2、字面量的方式创建正则 var demo = /abc/ //使用正则 var reg = /a/ reg.test(&quot;a&quot;) reg.test(&#x27;&#x27;) //test 方法就是用来检测传入的字符串，是否包含在指定的规则中 //返回值一定是一个布尔值 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、正则的范围标识： [abc]：查找方括号内任意一个字符。 [^abc]：查找不在方括号内的字符。 [0-9]：查找从 0 至 9 范围内的数字，即查找数字。 [a-z]：查找从小写 a 到小写 z 范围内的字符，即查找小写字母。 [A-Z]：查找从大写 A 到大写 Z 范围内的字符，即查找大写字母。 [A-z]：查找从大写 A 到小写 z 范围内的字符，即所有大小写的字母。 3、正则的词量和边界以及修饰符123456// /^[]$/严格模式 ^以x开头 $边界符 &#123;&#125; 量词console.log(/^a&#123;2,5&#125;$/.test(&#x27;aaaaa&#x27;));// . 匹配任意字符，除了换行符，想用的话，加个斜杠转义 \\d 匹配任意数字，等价于[0--9] \\w 匹配字母数字及下划线//中文 [\\u4e00-\\u9fa5] 4、贪婪模式和非贪婪模式（了解）非贪婪模式只是多了一个问号 1234567//贪婪模式var str = &#x27;aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc&#x27;console.log(str.match(/&lt;div&gt;.*&lt;\\/div&gt;/));//非贪婪模式var str = &#x27;aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc&#x27;console.log(str.match(/&lt;div&gt;.*?&lt;\\/div&gt;/g));","categories":[],"tags":[]},{"title":"DOM笔记","slug":"DOM笔记","date":"2022-03-29T10:37:25.695Z","updated":"2022-04-11T11:20:11.376Z","comments":true,"path":"2022/03/29/DOM笔记/","link":"","permalink":"http://example.com/2022/03/29/DOM%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、DOM 的介绍1231.*当创建好一个页面并加载到浏览器时，DOM就悄然而生！！！，它会把网页文档（html页面）转换为一个文档对象，*主要功能是处理网页内容，dom就是操作页面中的元素！！！2.顶级对象是 document, 通过 document 提供的一系列方法能够获取到对应的元素，是一个DOM对象3.可以操作元素的样式、属性、内容 二、获取元素的方法、事件的格式1234567891011121314151617181920212223//只能获取唯一id的元素，所以不带“s”document.getElementById() //获取元素的类名，可以批量获取所以带“s”，获取的元素会被放置在一个伪数组中，不能调用forEach方法，但是有length属性document.getElementsByClassName() //通过标签名获取元素，可以批量获取所以带“s”，获取的元素会被放置在一个伪数组中，不能调用forEach方法，但是有length属性document.getElementsByTagName()//通过表单的name属性获取元素，可以批量获取所以带“s” 输出的类型为 - NodeList，一般只用于获取表单元素，能调用forEach方法，有length属性document.getElementsByName()//HTML5 更新的选择器，选择单个的元素，有兼容性问题，一定要加选择符document.querySelector()//获取更多的元素，一般用于获取类名或者标签名的元素，结果为多个，是NodeList结构，可以使用 forEach方法document.querySelectorAll()//获取HTMl节点document.documentElement//获取body节点documnet.body 123456789101112131415164.注册事件的格式是，事件源.事件 = 事件处理程序btn.onclick = function() &#123;&#125;// 批量注册事件 for(var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function() &#123; // code &#125;&#125;//数组的forEach方法遍历lis.forEach(function(el) &#123; el.onclick = function() &#123; &#125;&#125;) 12345678//注意事项选择器的新方法和旧方法，都只会呈现两种状态1. 通过 getElementById 或者 querySelector 直接获取的元素 可以对 DOM 对象直接操作，注册事件，操作样式...2. 通过其他方法获取的元素，由于是伪数组，并不能直接操作 要么使用下标索引的方式提取出来 boxs[i] 要么使用 for 循环或者 forEach 的方式遍历操作 三、事件的类型12345//鼠标事件1.onclick 单击 2.onndblclick 双击 3.onmousemove 鼠标移动4.onmouseover &amp;&amp; onmouseout 移入移出 //这个会有冒泡特性，所以一般用的少5.onmouseenter &amp;&amp; onmouseleave 移入移出 //这个没有冒泡特性6.onmousedown 鼠标按下 onmouseup 鼠标弹起 12345//键盘事件1.onkeydown 键盘按下 2.onkeyup 键盘弹起 3.onkeypress 键盘按压4.event.keyCode 键码//onkeydown 和 onkeypress 区别？onkeypress区分大小写，对应的键码会不一样，不识别系统按键 12//表单事件1.onfocus 获得焦点 2.onblur 失去焦点 3.oninput 输入事件 4.onchange 当内容改变 1234系统内置事件 window.onload = &#123;&#125;// 会等待body中的内容全部渲染完毕再会执行事件赋值的函数，不需要我们手动调用，是浏览器内部由window进行处理 1、案例：鼠标移入高亮显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; ul,li&#123; list-style: none; &#125; a&#123; text-decoration: none; &#125; .list&#123; width: 200px; height: 150px; border: 1px solid black; &#125; .list li&#123; width: 200px; height: 50px; background-color: hotpink; text-align: center; line-height: 50px; &#125; .list li:nth-child(2)&#123; border-top: 1px solid black; border-bottom: 1px solid black; box-sizing: border-box; &#125; .list li a&#123; font-size: 20px; color: white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;大哥的桂芬&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;大哥的秀琴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;大哥的诸葛钢铁&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var liNodes = document.querySelectorAll(&#x27;.list &gt; li&#x27;); for (var i = 0; i &lt; liNodes.length; i++) &#123; liNodes[i].onmouseover = function() &#123; this.style.backgroundColor = &#x27;red&#x27;; &#125;; liNodes[i].onmouseout = function() &#123; this.style.backgroundColor = &#x27;green&#x27;; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2、keyCode思考：如何区分按下的是哪个键，所以需要区分键 区分键位，我们需要通过键码(keyCode)去区分，每次触发事件时，都会在事件的回调函数中有一个事件对象(event)，事件对象就是回调函数的第一个参数，每一次触发事件时，系统会自定帮我们把这一次触发事件的相关信息封装为一个事件对象，系统会把这个事件对象传给回调函数的第一个形参 12345678910111213&lt;input type=&quot;text&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var inputNode = document.querySelector(&quot;input&quot;); inputNode.onkeyup = function(e) &#123; if (e.keyCode === 13) &#123; console.log(&quot;回车&quot;); &#125; else if (e.keyCode === 16) &#123; console.log(&quot;shift&quot;); &#125; &#125; &#125;&lt;/script&gt; 3、案例：全选、全不选、反选（***）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 300px; margin: 100px auto; &#125; ul &#123; list-style: none; &#125; li &#123; line-height: 40px; margin-bottom: 10px; &#125; .box-content &#123; margin-top: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-top&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot;&gt; 全选 &lt;button id=&quot;btn&quot;&gt;真正的反选&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;box-content&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //获取对应的元素 var checkAll = document.querySelector(&#x27;#checkAll&#x27;) var btn = document.querySelector(&#x27;#btn&#x27;) var box = document.querySelector(&#x27;.box-content&#x27;) // 获取底部盒子内的所以input var ipts = box.querySelectorAll(&#x27;input&#x27;) // 注册事件 全选和全不选,这个是全选和全不选按钮事件 checkAll.onclick = function() &#123; ipts.forEach(function(el)&#123; el.checked = checkAll.checked &#125;) &#125; //反选 ipts.forEach(function(el)&#123; el.onclick = function() &#123; //需要再给下面的5个复选框遍历，只要有一个未选中，就结束循环 // var bool = true // for(var i = 0;i &lt; ipts.length;i++)&#123; // // 取反 // if(!ipts[i].checked)&#123; // bool = false // break // &#125; // &#125; var arr = Array.of(ipts) var bool = arr.every(function(val)&#123; return val.checked &#125;) checkAll.checked = bool &#125; &#125;) btn.onclick = function() &#123; ipts.forEach(function(el) &#123; el.checked = !el.checked &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、批量注册事件&amp;&amp;排他思想（**）干掉所有人，留下我自己 12345678910111213141516171819202122232425// 排他思想第一步就是要操作所有的元素，那么就一定要遍历获取到的元素.forEach(function(el) &#123; el.onclick = function() &#123; //先把所有的元素样式去掉 排他思想 获取到的元素.forEach(function(item) &#123; item.style = &#x27;&#x27; &#125;) //当前的元素单独添加样式 el.style.color = &#x27;skyblue&#x27; &#125;&#125;)for (var i = 0; i &lt; 获取到的元素.length; i++) &#123; 获取到的元素[i].onclick = function () &#123; //先把所有的元素样式去掉 排他思想 for (var j = 0; j &lt; 获取到的元素.length; j++) &#123; 获取到的元素[j].className = &quot; &quot;; &#125; //当前的元素单独添加样式 this.className = this.className + &quot;active&quot;; &#125;&#125;1.在循环结束的后面，单独给自己设置样式2.获取到的元素[i] this el 都代表自身元素 1、案例：选项卡（***)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box button&#123; width: 80px; height: 40px; background-color: hotpink; color: #fff; margin-right: 25px; &#125; #box div&#123; width: 300px; height: 100px; background-color: aqua; &#125; .cls&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;button&gt;飞天&lt;/button&gt; &lt;button&gt;遁地&lt;/button&gt; &lt;button&gt;无所不能&lt;/button&gt; &lt;div&gt;sczd az ada&lt;/div&gt; &lt;div&gt;a cads axc &lt;/div&gt; &lt;div&gt; acasdf q&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var box = document.querySelector(&#x27;#box&#x27;) var btns = box.querySelectorAll(&#x27;button&#x27;) var Div = box.querySelectorAll(&#x27;div&#x27;) Div.forEach(function(el,index)&#123; el.onclick = function() &#123; btns.forEach(function(item,i)&#123; item.className = &quot; &quot; Div[i].style.display = &quot;none&quot; &#125;) el.className = &quot;cls&quot; Div[index].style.display = &quot;block&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、轮播图根据点的索引更改透明度（*）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul, ol &#123; position: relative; list-style: none; &#125; body &#123; padding: 20px; &#125; ul li &#123; position: absolute; top: 0; left: 0; width: 300px; height: 200px; transition: all 0.3s ease-in; &#125; ul li:first-of-type &#123; z-index: 1; &#125; ul li img &#123; width: 100%; height: 100%; &#125; ol &#123; z-index: 999; display: flex; &#125; ol li &#123; width: 10px; height: 10px; background-color: #333; margin: 10px; border-radius: 50%; &#125; .cls &#123; background-color: #f8f8f8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/01.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/02.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/03.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;../1.imgs/04.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class=&quot;cls&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; var ol = document.querySelector(&#x27;ol&#x27;) console.log(ol); var ollis = ol.querySelectorAll(&#x27;li&#x27;) console.log(ollis); var ul = document.querySelector(&#x27;ul&#x27;) console.log(ul); var ullist = ul.querySelectorAll(&#x27;li&#x27;) console.log(ullist); ollis.forEach(function(el,index)&#123; el.onmouseenter= function() &#123; ollis.forEach(function(item,i)&#123; item.className = &quot; &quot; ullist[i].style.opacity = 0 &#125;) this.className = &#x27;cls&#x27; console.log(this); ullist[index].style.opacity = 1 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、二级菜单（***）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; a &#123; text-decoration: none; color: #333; &#125; .content &#123; margin: 100px auto; padding: 20px 120px; background-color: #ccc; &#125; .nav &#123; display: flex; &#125; .nav li &#123; position: relative; padding: 5px 10px; margin: 0 5px; background-color: #eee; &#125; .nav ul &#123; position: absolute; top: 30px; left: 0; display: none; &#125; /* .nav li:hover ul &#123; display: block; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;content&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第01项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第02项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第03项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第04项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;span&gt;这是第05项&lt;/span&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;li&gt;这是二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var lis = document.querySelectorAll(&#x27;.nav &gt; li&#x27;) console.log(lis); lis.forEach(function(el)&#123; el.onmouseenter = function()&#123; lis.forEach(function(item)&#123; var ulbox = item.querySelector(&#x27;ul&#x27;) ulbox.style.display = &quot;none&quot; &#125;) var curul = el.querySelector(&#x27;ul&#x27;) curul.style.display = &quot;block&quot; &#125; el.onmouseleave = function()&#123; var curul = el.querySelector(&#x27;ul&#x27;) curul.style.display = &quot;none&quot; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、操作元素的样式、属性、内容操作样式：行内样式、类样式1234567891011121314行内样式：//操作DOM对象的行内样式获取的DOM对象.style.样式属性 = &#x27;值&#x27;// 如果样式属性中间有中横线，横杠后面的首字母拼接之后需要大写font-size =&gt; fontSize// 如果设置的样式为多个 box.style = &#x27;color: red; font-size: 30px;&#x27;类样式：//操作DOM对象的类样式获取的DOM对象.className = &#x27;&#x27;//赋值的类名，会覆盖原先的类名，如果都要实现样式，一定要在字符串中同时设置box.className = &#x27;demo cls&#x27;//ps:要添加的类名，一定是 css 样式表中提前声明好的类名 操作属性：Attribute（**）1234567891011//操作标签的属性 Attribute方法getAAttribute 获取属性值 setAttribute 设置属性和值 removeAttribute 移除属性//DOM元素的对象属性，操作DOM元素的对象属性和原始操作OBject的属性一样，使用打点或者中括号的方式console.dir()//可以展开DOM对象的详情1.早期，标签的自定义属性不会添加到dom对象中，dom对象中添加的属性，不会映射到标签上//HTML5 更新了一种格式，打破了这个规则2.只要是在标签中添加的 data- 开头的属性，会被写入到dom对象的 dataset 属性中3.只要是通过 DOM 对象设置的属性，会自动映射到标签的属性上，并且自动加上 data- 标识4.如果在标签上用了中横线，在获取的时候要写小驼峰，如果设置的js属性是小驼峰，会自动解析为中横线 操作内容：innerHTML、innerText、textContent、value（***）123456789101112操作内容：//可以获取和设置元素的内容innerHTML 和 innerText1.innerHTML 可以获取到标签，在设置的时候也会识别并渲染标签2.innerText 只会获取纯文本//innerText 和 textContent1.innerText 只会获取纯文本2.textContent 只有 IE8 以上才能识别和使用3.textContent 能获取隐藏元素的内容，并且保留内容的换行格式//value：表单属性,表单的内容是通过value获取的console.log(input.value) 1、案例：兼容性封装读写内容1123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;pp&quot;&gt;老马&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; //如果用户使用的是高级浏览器就自动的通过textContent去操作内容 //如果用户使用的是低级浏览器就自动的通过innerText去操作内容 var pNode = document.getElementById(&#x27;pp&#x27;); // console.log(pNode.textContent);不能直接写，因为这样只能满足高级浏览器的用户操作内容，低级浏览器不能 // console.log(getOrSetContent(pNode));//兼容性获取P内部的内容 getOrSetContent(pNode, &#x27;老马过河&#x27;); //兼容性设置p内部的内容 function getOrSetContent(node, content) &#123; if (arguments.length === 1) &#123; //在获取内容 if (node.textContent) &#123; //证明是高级 return node.textContent; &#125; else &#123; //低级浏览器 return node.innerText; &#125; &#125; else if (arguments.length === 2) &#123; //在设置内容 if (node.textContent) &#123; //证明是高级 node.textContent = content; &#125; else &#123; //低级浏览器 node.innerText = content; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2、案例：兼容性封装读写内容2（优化）1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;pp&quot;&gt;老马&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; //如果用户使用的是高级浏览器就自动的通过textContent去操作内容 //如果用户使用的是低级浏览器就自动的通过innerText去操作内容 var pNode = document.getElementById(&#x27;pp&#x27;); // console.log(pNode.textContent);不能直接写，因为这样只能满足高级浏览器的用户操作内容，低级浏览器不能 // console.log(getOrSetContent(pNode));//兼容性获取P内部的内容 getOrSetContent(pNode, &#x27;老马过河&#x27;); //兼容性设置p内部的内容 //函数优化 function getOrSetContent(node, content) &#123; if (arguments.length === 1) &#123; //在获取内容 // return node.textContent?node.textContent:node.innerText return node.textContent || node.innerText; &#125; else if (arguments.length === 2) &#123; //在设置内容 node.textContent ? node.textContent = content : node.innerText = content; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 六、节点操作1、什么是节点​ 什么是节点，节点的类型有哪些，我们需要学习哪些节点，节点的关系是什么样的。 ​ 在 DOM 树中，组成的最小单位就是节点 (Node)，当网页在浏览器中打开的时候，就会把所有的页面内容渲染成对应节点，每一个节点都会有 nodeType, nodeValue, nodeName 三个属性 ​ 节点一共有 12 种类型，还分别编号了，元素节点1，属性节点2，文本节点3，注释节点8 2、总结： nodeType nodeName nodeValue 元素节点 1 元素名大写 null 属性节点 2 属性名 属性值 文本节点 3 #text 文本内容 注释节点 8 #comment 注释内容 12345678910111.node.nodeType功能：返回节点类型，只读console.log(div,nodeType)2.node.nodeName功能：返回元素的标签名，以大写形式表示，只读consloe.log(div.nodeName);3.nodeValue功能：返回text或Comment（注释）节点的文本内容，可读写consloe.log(div.nodeValue); 3、创建和操作节点的方法12345678910111213141516171819202122232425262728293031323334获取元素只需要记住：children 子元素节点 parentNode 父节点 nextElementSibling 下一个兄弟元素节点 previousElementSibling 上一个兄弟元素节点//创建元素,有返回值，是一个dom对象，可以设置事件，赋值内容，但是不会立马在网页中呈现doucment.createElement(&#x27;标签名&#x27;)例：//createElement 创建元素var h2box = document.createElement(&quot;h2&quot;)h2box.innerText = &#x27;12345&#x27;//appendChild 追加节点app.appendChild(h2box)//删除box.removeChild() //删子元素，一定要传入要删除的那个节点box.remove() //删自己，不需要传参//添加父盒子.insertBefore(参数1，参数2)参数1：要添加的那个新节点参数2：参考父盒子内的指定子节点父盒子.appendChild(参数)参数：要添加的子节点，会在父盒子的队尾出现//替换父盒子.replaceChild(参数1，参数2)参数1：要替换的那个新节点参数2：在父盒子内要被替换的指定子节点//拓展 cloneNode()没有参数：只会克隆一层盒子有参数为true：会深层克隆整个盒子只克隆的话，不会在页面中同步出现 七、事件注册的 DOM2 方式（事件监听）绑定与解绑123456789101112131415box.addEventListener(&#x27;事件名称&#x27;， function() &#123; // 事件处理程序&#125;)// 如果你需要解绑，一定要把注册事件的回调函数写出来，并且命名box.removeEventListener(&#x27;事件名称&#x27;, 事件处理函数的名称)绑定事件函数this和绑定元素有关系，但是和实际可能操作的子元素无关box.addEventListener(&#x27;click&#x27;,function(event)&#123;//console.log(this)event.targetevent.srcElement&#125;,true) 捕获addEventListener(&#x27;click&#x27;,function()&#123;&#125;,false) 冒泡 1、注册事件的初级封装1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#x27;btn&#x27;) // //高级浏览器 // btn.addEventListener(&#x27;click&#x27;,function()&#123; // console.log(100); // &#125;) // //低级浏览器 // btn.attachEvent(&#x27;onclick&#x27;,function()&#123; // console.log(100); // &#125;) //封装的过程就是，把相同的部分放进一个函数，把不同的作为参数 function addE(el,type,fn)&#123; //事件源 注册事件的方法 事件的名称 if( el.addEventListener)&#123; el.addEventListener(type,fn) &#125;else&#123; el.attachEvent(&#x27;on&#x27; + type,fn) &#125; &#125; //封装之后的调用 addE(btn,&quot;click&quot;,function()&#123; console.log(100); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、注册事件的注意事项：注册事件监听的时候，参数2不允许提前调用 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; //注册事件监听的时候，参数2不允许提前调用 btn.addEventListener(&#x27;click&#x27;,function() &#123; fn(100) &#125;) function fn(n)&#123; console.log(n); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、事件流事件流描述的就是从页面中接收事件的顺序。而早期的IE和Netscape提出了完全相反的事件流概念，IE事件流是事件冒泡，而Netscape的事件流就是事件捕获。 12DOM2级事件规定的事件流包括三个阶段： （1）事件捕获阶段 （2）处于目标阶段 （3）事件冒泡阶段捕获---目标---冒泡 1、阻止事件冒泡那个目标元素的事件需要阻止就加入如下代码： 1event.stopPropagation(); // 专门用来阻止事件冒泡 九、事件委托干什么：事件委派过程当中依赖了事件冒泡 阻止事件冒泡，是为了解决冒泡给我们带来的困扰 事件冒泡的好处就是可以进行事件委派（事件委托，事件代理）；把子元素的事件监听添加给父（祖先）元素，把子元素发生的事件委托给父元素进行处理； 怎么用： 当一个元素内部儿子很多，并且每个儿子都要添加相同的事件的时候，我们可以使用事件委派来提高效率； 出现新添加的东西，并且新添加的东西要和老的拥有同样的行为；此时我们就想事件委派；不用事件委派，老的身上会有想要的行为，而新添加的没有； 用法：事件委托的第一种12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;这是第1&lt;/li&gt; &lt;li&gt;这是第2&lt;/li&gt; &lt;li&gt;这是第3&lt;/li&gt; &lt;li&gt;这是第4&lt;/li&gt; &lt;li&gt;这是第5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var lis = document.querySelectorAll(&#x27;li&#x27;) var ulbox = document.querySelector(&#x27;ul&#x27;) //批量注册事件 // lis.forEach(function(el)&#123; // el.onclick = function()&#123; // console.log(111); // &#125; // &#125;) ulbox.onclick = function(event)&#123; //event 事件对象 target目标元素 var curEl = event.target //只有当前元素是LI的时候，才会触发事件 nodeName 节点的名称(大写) if(curEl.nodeName = &quot;LI&quot;)&#123; console.log(curEl.innerText); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件委托的第二种123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;这是1&lt;/li&gt; &lt;li&gt;这是2&lt;/li&gt; &lt;li&gt;这是3&lt;/li&gt; &lt;li&gt;这是4&lt;/li&gt; &lt;li&gt;这是5&lt;/li&gt; &lt;/ul&gt; &lt;button id=&quot;btn&quot;&gt;点我添加新节点&lt;/button&gt; &lt;script&gt; var ulbox = document.querySelector(&#x27;ul&#x27;) var lis = ulbox.querySelectorAll(&#x27;li&#x27;) var btn = document.querySelector(&#x27;#btn&#x27;) btn.onclick = function()&#123; var newli = document.createElement(&#x27;li&#x27;) newli.textContent = &quot;这是新的节点&quot; ulbox.appendChild(newli) &#125; //事件源一定是父盒子，是页面中存在的盒子 ulbox.onclick = function(event)&#123; var curEl = event.target//通过它获取的是真正触发事件的那个元素 if(curEl.nodeName === &#x27;LI&#x27;)&#123;//根据节点名称去判断是否为想要的那个元素 console.log(curEl.innerText); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1、学员信息列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style&gt; table &#123; border: 1px solid #ccc; border-collapse: collapse; &#125; tr, td, th &#123; border: 1px solid #ccc; padding: 20px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;序号： &lt;input type=&quot;text&quot; id=&quot;a&quot;&gt;姓名： &lt;input type=&quot;text&quot; id=&quot;uname&quot;&gt;性别： &lt;input type=&quot;text&quot; id=&quot;gender&quot;&gt;年龄： &lt;input type=&quot;text&quot; id=&quot;age&quot;&gt;&lt;button id=&quot;btn&quot;&gt;添加学员&lt;/button&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;常盛瑞&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;王云飞&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script&gt; var dels = document.querySelectorAll(&#x27;tbody &gt; tr &gt; td &gt; a&#x27;) var tbody = document.querySelector(&#x27;tbody&#x27;) var btn = document.querySelector(&quot;#btn&quot;) dels.forEach(function(el)&#123; el.onclick = function()&#123; this.parentNode.parentNode.remove() &#125; &#125;) btn.addEventListener(&#x27;click&#x27;,function()&#123; var trbox = document.createElement(&#x27;tr&#x27;) var td1 = document.createElement(&#x27;td&#x27;) td1.textContent = a.value var td2 = document.createElement(&#x27;td&#x27;) td2.textContent = document.querySelector(&#x27;#uname&#x27;).value var td3 = document.createElement(&#x27;td&#x27;) td3.textContent = document.querySelector(&#x27;#gender&#x27;).value var td4 = document.createElement(&#x27;td&#x27;) td4.textContent = document.querySelector(&#x27;#age&#x27;).value var td5 = document.createElement(&#x27;td&#x27;) td5.innerHTML = &#x27;&lt;a href = &quot;#&quot;&gt;删除&lt;/a&gt;&#x27; trbox.appendChild(td1) trbox.appendChild(td2) trbox.appendChild(td3) trbox.appendChild(td4) trbox.appendChild(td5) tbody.appendChild(trbox) &#125;) tbody.addEventListener(&#x27;click&#x27;,function(event)&#123; if(event.target.nodeName === &quot;A&quot;)&#123; event.target.parentNode.parentNode.remove() &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、两种鼠标经过的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background: gray; line-height: 100px; text-align: center; margin:20px; padding: 50px; box-sizing: border-box; &#125; div span&#123; width: 100px; height: 100px; display: inline-block; background: white; &#125; &lt;/style&gt; &lt;script&gt; /* [注]经过子节点会重复触发 mouseover 鼠标移入 mouseout 鼠标移出 [注]经过子节点不会重复触发 IE8以后才有 mouseenter 鼠标移入 mouseleave 鼠标移出 */ window.onload = function ()&#123; var aDivs = document.getElementsByTagName(&quot;div&quot;); var i = 0; aDivs[0].onmouseover = function ()&#123; var oSpan = this.getElementsByTagName(&quot;span&quot;)[0]; oSpan.innerHTML = i++; &#125; var j = 0; aDivs[1].onmouseenter= function ()&#123; var oSpan = this.getElementsByTagName(&quot;span&quot;)[0]; oSpan.innerHTML = j++; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;mouseover&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;mouseenter&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十、鼠标坐标1、浏览器中查看鼠标坐标的三种方式123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; height: 2000px; &#125; body&#123; margin: 30px; padding: 20px; &#125; #box&#123; width: 300px; height: 300px; background-color: #ccc; margin: 20px; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;/div&gt; &lt;script&gt; window.onload = function()&#123; document.documentElement.onmousemove = function(event) &#123; //视口的坐标只会根据窗口计算，页面滚动跟它没关系 console.log(&#x27;基于视口的坐标:&#x27; + event.clientX + &#x27;,&#x27; + event.clientY); //页面的坐标跟页面的位置计算，不考虑视口的位置 console.log(&#x27;基于页面的坐标：&#x27; + event.pageX + &#x27;,&#x27; + event.pageY); //页面的坐标是基于当前触发事件的目标元素的左上角开始计算 console.log(&#x27;基于自身的距离：&#x27; + event.offsetX + &#x27;,&#x27; + event.offsetY); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、封装好的图片拖拽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin: 0;padding: 0;&#125; body&#123; background-color: #000; &#125; img&#123; position: fixed; top: 0; left: 0; width: 230px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img draggable=&quot;false&quot; src=&quot;../1.imgs/pc_activity_1_qcode.png&quot; alt=&quot;&quot;&gt; &lt;script&gt; //这是封装好的拖拽效果 var imgbox = document.querySelector(&#x27;img&#x27;) function limitDrag(node)&#123; node.onmousedown = function (ev)&#123; var e = ev || window.event;//window.event是兼容写法 //记录鼠标按下的位置和被拖拽物体相对距离 var offsetX = e.clientX - node.offsetLeft; var offsetY = e.clientY - node.offsetTop; // 一致保持相对位置，相对距离 document.onmousemove = function (ev)&#123; var e = ev || window.event; var l = e.clientX - offsetX; var t = e.clientY - offsetY; //限制出界 if(l &lt;= 0 )&#123; l = 0; &#125; var windowWidth = document.documentElement.clientWidth || document.body.clientWidth; if(l &gt;= windowWidth - node.offsetWidth)&#123; l = windowWidth - node.offsetWidth; &#125; if(t &lt;= 0)&#123; t = 0; &#125; var windowHight = document.documentElement.clientHeight || document.body.clientHeight; //这里不加的话 可以向下无限延伸 if(t &gt;= windowHight - node.offsetHeight)&#123; t = windowHight - node.offsetHeight; &#125; // 这里是图片拖动 node.style.left = l + &quot;px&quot; node.style.top = t + &quot;px&quot; &#125; &#125; //取消拖拽 document.onmouseup = function ()&#123; document.onmousemove = null; &#125; &#125; limitDrag(imgbox) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 盒子在浏览器中的尺寸三大系列：clicent系列、offset系列、scroll系列 1、clicent系列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; margin: 100px; width: 100px; height: 100px; background-color: red; border: 50px solid #333; padding: 50px; overflow: scroll; direction: rtl; &#125; .son &#123; height: 300px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1.0 获取元素 var box = document.querySelector(&#x27;.box&#x27;) // 2.0 直接获取元素的尺寸 client 系列 不包含 border 边框 console.log(box.clientHeight + &#x27;： 元素的高度&#x27;) // 183 height + 上padding + 下padding 如果有滚动条会减去滚动条的值 console.log(box.clientWidth + &#x27;： 元素的宽度&#x27;) //183 width + 左padding + 右padding console.log(box.clientTop + &#x27;： 元素的Top 就是 上边框的值&#x27;) //50 一般是单边的边框的值，如果有滚动条的话，是边框加滚动条的值 console.log(box.clientLeft + &#x27;： 元素的Left 左边框的值&#x27;)//67 一般是单边的边框的值，如果有滚动条的话，是边框加滚动条的值 // 其实 clinetLeft 获取的是边框和 滚动条的距离 // 只是平常不怎么使用而已 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、offset系列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body &#123; padding: 20px; border: 10px solid #ccc; margin: 10px; &#125; .box &#123; margin: 146px; width: 100px; height: 100px; background-color: red; border: 50px solid #333; padding: 50px; &#125; .son &#123; height: 100%; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1.0 获取元素 var box = document.querySelector(&#x27;.box&#x27;) // 2.0 直接获取元素的尺寸 offset 系列 计算元素的 border + padding + content console.log(box.offsetHeight + &#x27;： 元素的高度&#x27;) //300 height + padding + border console.log(box.offsetWidth + &#x27;： 元素的宽度&#x27;)//300 width + padding + border // offsetTop / offsetLeft 元素距离 body 的外边距 console.log(box.offsetTop + &#x27;： 元素的Top &#x27;) //默认情况下 是距离body的距离，top不会有默认的8像素 //默认情况下 是距离body的距离 如果不清除默认样式，没有对html、body设置内外边距值，浏览器会有默认的8像素，不会加自身的padding值 console.log(box.offsetLeft + &#x27;： 元素的Left&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、scroll系列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; padding: 30px; height: 3000px; &#125; .box &#123; width: 300px; height: 160px; background-color: red; padding: 40px; border: 19px solid #000; overflow: auto; &#125; .son &#123; width: 600px; height: 500px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1.0 获取元素 var box = document.querySelector(&#x27;.box&#x27;) // 2.0 直接获取元素的尺寸 scroll 系列 不包含border console.log(box.scrollHeight + &#x27;： 元素的高度&#x27;) console.log(box.scrollWidth + &#x27;： 元素的宽度&#x27;) // ！！！ 很重要的一个概念 scrollTop 计算的是内容滚动出去之后的那个距离 console.log(box.scrollTop + &#x27;： 元素的Top &#x27;) // console.log(box.clientLeft + &#x27;： 元素的Left &#x27;) // 3.0 给父盒子添加滚动事件 box.onscroll = function() &#123; console.log(box.scrollTop) console.log(box.scrollLeft) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 放大镜案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #small&#123; position: absolute; left: 30px; top: 30px; width: 400px; height: 400px; &#125; #small img&#123; width: 100%; height: 100%; &#125; #small .mark&#123; position: absolute; top: 0; left: 0; width: 100px; height: 100px; opacity: 0.4; background-color: #fff; display: none; &#125; #big&#123; position: absolute; left: 500px; top: 30px; width: 200px; height: 200px; border: 1px solid #000; overflow: hidden; display: none; &#125; #big img&#123; position: absolute; top: 0; left: 0; width: 800px; height: 800px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;small&quot;&gt; &lt;img src=&quot;../1.imgs/linght.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mark&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;big&quot;&gt; &lt;img src=&quot;../1.imgs/linght.jpg&quot; alt=&quot;&quot; id=&quot;pic&quot;&gt; &lt;/div&gt; &lt;script&gt; var small = document.querySelector(&#x27;#small&#x27;) var big = document.querySelector(&#x27;#big&#x27;) var mark = document.querySelector(&#x27;.mark&#x27;) var imgbox = document.querySelector(&#x27;#pic&#x27;) small.onmouseenter = function()&#123; mark.style.display = &quot;block&quot; big.style.display = &quot;block&quot; &#125; small.onmouseleave = function()&#123; mark.style.display = &quot;none&quot; big.style.display = &quot;none&quot; &#125; small.onmousemove = function(event)&#123; var e = event || window.event var l = e.clientX - small.offsetLeft - 50 var t = e.clientY - small.offsetTop - 50 if(l &lt;= 0) &#123; l = 0 &#125; if(l &gt;= 300)&#123; l = 300 &#125; if(t &lt;= 0) &#123; t = 0 &#125; if(t &gt;= 300)&#123; t = 300 &#125; mark.style.left = l + &quot;px&quot; mark.style.top = t + &quot;px&quot; imgbox.style.left = l* -2 + &quot;px&quot; imgbox.style.top = t* -2 + &quot;px&quot; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十一、轮播图常用的轮播图有两种，一种是滑动轮播图，这是用的最多的一种，还有一种是渐变轮播图，轮播图都是搭配封装好的动画库一起使用，效率会高很多 1、滑动轮播图（结构）1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;&gt; &lt;script src=&quot;./js/animate.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 主盒子 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 左右按钮 --&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;div class=&quot;arr-left&quot;&gt;&amp;lt;&lt;/div&gt; &lt;div class=&quot;arr-right&quot;&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 图 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-01.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-02.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-03.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-04.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-05.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-06.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 按钮 --&gt; &lt;ol&gt; &lt;li class=&quot;cur&quot;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、滑动轮播图（样式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* 清除默认样式 */* &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;img &#123; /* 让图片跟父盒子的大小一样 */ width: 100%; display: block;&#125;.container &#123; position: relative; width: 520px; /* 给高度为了让ol能定位到图片上面去 */ height: 346px; margin: 100px auto; overflow: hidden;&#125;.arrow &#123; /* 让左右两边的按钮定位在父盒子里面 */ position: absolute; top: 50%; left: 0; /* 让它们在y轴居中显示 */ transform: translateY(-50%); width: 100%; z-index: 999; display: none;&#125;.arr-left, .arr-right &#123; position: absolute; top: 50%; transform: translateY(-50%); color: #fff; font-size: 30px; /* 如果觉得夹角不好看，那就改变字体样式 */ font-family: simsun; width: 40px; height: 60px; text-align: center; line-height: 60px; background-color: rgba(0, 0, 0, 0.5); cursor: pointer;&#125;.arr-left &#123; left: 10px;&#125;.arr-right &#123; right: 10px;&#125;ul &#123; width: 5000px; /* 为了让看的出图片在走，也加个定位然后去修改left的值 */ position: relative; left: 0; /* transition: left 0.4s linear; */&#125;ul li &#123; /* 让图片一字排开，然后再用溢出隐藏 */ float: left; width: 520px;&#125;ol &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);&#125;ol li &#123; float: left; margin: 0 5px; font-size: 12px; width: 15px; height: 15px; border-radius: 50%; text-align: center; line-height: 15px; cursor: pointer; background-color: rgba(255, 255, 255, 0.5);&#125;ol li.cur &#123; background-color: #fff;&#125; 3、滑动轮播图（行为）（动画库另外找）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106window.onload = function()&#123;// 1.获取 按钮、图片父盒子、父盒子、左右按钮、图片宽度var ollis = document.querySelectorAll(&#x27;ol li&#x27;)var ulbox = document.querySelector(&#x27;ul&#x27;)var container = document.querySelector(&#x27;.container&#x27;)var arrow = document.querySelector(&#x27;.arrow&#x27;)var rightbox = document.querySelector(&#x27;.arr-right&#x27;)var leftbox = document.querySelector(&#x27;.arr-left&#x27;)var distTime = 10;// 一张图片的距离var imgwidth = ulbox.children[0].offsetWidth// 修改了结构，这是为了让能看见的图片显示的是第一张ulbox.style.left = -imgwidth + &#x27;px&#x27;//在前面加一张图片var firimg = ulbox.children[0].cloneNode(true)//在最后面加一张图片var lastimg = ulbox.children[ulbox.children.length - 1].cloneNode(true)ulbox.appendChild(firimg)ulbox.insertBefore(lastimg,ulbox.children[0])// 2.操作ol中的小圆点样式ollis.forEach(function(el,index) &#123; el.onclick = function() &#123; ollis.forEach(function(item) &#123; item.removeAttribute(&quot;class&quot;) &#125;) el.className = &quot;cur&quot; ani(ulbox, &#x27;left&#x27;, -(index + 1) *imgwidth) count = index + 1 &#125;&#125;)// 3.显示左右按钮container.onmouseover = function()&#123; arrow.style.display = &quot;block&quot; clearInterval(timer)&#125;container.onmouseout = function()&#123; arrow.style.display = &quot;none&quot; clearInterval(timer) timer = setInterval(function()&#123; rightbox.onclick() &#125;,2000)&#125;var count = 1var flag = true// 4.点击左右按钮切换rightbox.onclick = function ()&#123; if(flag)&#123; flag = false count++ if(count &gt; 6) &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth, function()&#123; count = 1 ulbox.style.left = -count * imgwidth + &quot;px&quot; it(count - 1) flag = true &#125;) &#125;else &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth,function() &#123; flag = true &#125;) it(count - 1) &#125; &#125;&#125;leftbox.onclick = function ()&#123; if(flag)&#123; count-- if(count &lt;= 0) &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth, function()&#123; count = 6 ulbox.style.left = -count * imgwidth + &quot;px&quot; it(count - 1) flag = true &#125;) &#125;else &#123; ani(ulbox,&#x27;left&#x27;, -count * imgwidth,function()&#123; flag = true &#125;) it(count - 1) &#125; &#125;&#125;//封装一个排他function it(n)&#123; ollis.forEach(function(item) &#123; item.removeAttribute(&quot;class&quot;) &#125;) ollis[n].className = &quot;cur&quot;&#125;// 5.自动轮播var timer = setInterval(function()&#123; rightbox.onclick()&#125;,2000)&#125; 4、渐变轮播图（结构）1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/swiper.css&quot;&gt; &lt;script src=&quot;./js/style.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 主盒子 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 左右按钮 --&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;div class=&quot;arr-left&quot;&gt;&amp;lt;&lt;/div&gt; &lt;div class=&quot;arr-right&quot;&gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 图 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-01.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-02.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-03.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-04.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-05.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./imgs/pic-06.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 按钮 --&gt; &lt;ol&gt; &lt;li class=&quot;cur&quot;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、渐变轮播图（样式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 清除默认样式 */* &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;img &#123; /* 让图片跟父盒子的大小一样 */ width: 100%; display: block;&#125;.container &#123; position: relative; width: 520px; /* 给高度为了让ol能定位到图片上面去 */ height: 346px; margin: 100px auto; /* overflow: hidden; */&#125;.arrow &#123; /* 让左右两边的按钮定位在父盒子里面 */ position: absolute; top: 50%; left: 0; /* 让它们在y轴居中显示 */ transform: translateY(-50%); width: 100%; z-index: 999; display: none;&#125;.arr-left, .arr-right &#123; position: absolute; top: 50%; transform: translateY(-50%); color: #fff; font-size: 30px; /* 如果觉得夹角不好看，那就改变字体样式 */ font-family: simsun; width: 40px; height: 60px; text-align: center; line-height: 60px; background-color: rgba(0, 0, 0, 0.5); cursor: pointer;&#125;.arr-left &#123; left: 10px;&#125;.arr-right &#123; right: 10px;&#125;ul &#123; position: relative;&#125;ul li &#123; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity .8s ease-in-out;&#125;ul li:first-of-type&#123; opacity: 1; z-index: 1;&#125;ol &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); z-index: 88;&#125;ol li &#123; float: left; margin: 0 5px; font-size: 12px; width: 15px; height: 15px; border-radius: 50%; text-align: center; line-height: 15px; cursor: pointer; background-color: rgba(255, 255, 255, 0.5);&#125;ol li.cur &#123; background-color: #fff;&#125; 6、渐变轮播图（行为）（不用加动画库） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980window.addEventListener(&#x27;load&#x27;, function() &#123; // 获取 按钮、图片父盒子、父盒子、左右按钮、图片宽度 var ollis = document.querySelectorAll(&#x27;ol &gt; li&#x27;) var ulbox = document.querySelector(&#x27;ul&#x27;) var container = document.querySelector(&#x27;.container&#x27;) var arrow = document.querySelector(&#x27;.arrow&#x27;) var rightbox = document.querySelector(&#x27;.arr-right&#x27;) var leftbox = document.querySelector(&#x27;.arr-left&#x27;) // 操作ol中的小圆点样式 ollis.forEach(function(el,index) &#123; el.onclick = function() &#123; fn(index) count = index &#125; &#125;) // 浅封装一下排他 function fn(n) &#123; // 排他 ollis.forEach(function(item, i) &#123; item.removeAttribute(&#x27;class&#x27;) // 以此次遍历同步操作ulBox ulbox.children[i].style.opacity = 0 &#125;) ollis[n].className = &#x27;cur&#x27; ulbox.children[n].style.opacity = 1 &#125; // 3.0 鼠标经过大盒子，显示左右按钮 container.addEventListener(&#x27;mouseover&#x27;, function() &#123; arrow.style.display = &#x27;block&#x27; clearInterval(timer) &#125;) container.addEventListener(&#x27;mouseout&#x27;, function() &#123; arrow.style.display = &#x27;none&#x27; clearInterval(timer) timer = setInterval(function() &#123; rightbox.click() &#125;, 2000) &#125;) // 4.0 左右按钮点击事件 var count = 0 var flag = true rightbox.addEventListener(&#x27;click&#x27;, function() &#123; if(flag) &#123; flag = false count++ if(count &gt; ollis.length - 1) count = 0 fn(count) &#125; &#125;) leftbox.addEventListener(&#x27;click&#x27;, function() &#123; if(flag) &#123; flag = false count-- if(count &lt; 0) count = ollis.length - 1 fn(count) &#125; &#125;) // 在监听谁的渐变？ ul &gt; li 以前有一个监听动画结束的事件 webkitAnimationEnd webkitTransitionEnd for(var i = 0; i &lt; ulbox.children.length;i++)&#123; ulbox.children[i].addEventListener(&quot;webkitTransitionEnd&quot;,function()&#123; flag = true &#125;) &#125; // 5.0 自动轮播 var timer = setInterval(function() &#123; // 其实就是右边按钮的点击 rightbox.click() &#125;, 2000)&#125;)","categories":[],"tags":[]}],"categories":[],"tags":[]}